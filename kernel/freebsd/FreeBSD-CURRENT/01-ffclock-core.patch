FFclock core

Core set of changes to support a feed-forward clock within the kernel.

---
 conf/NOTES       |    8 
 conf/options     |    1 
 kern/kern_tc.c   |  493 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 kern/subr_rtc.c  |    8 
 sys/_ffcounter.h |   43 ++++
 sys/timeffc.h    |   98 ++++++++++
 6 files changed, 651 insertions(+)

Index: sys/conf/NOTES
===================================================================
--- sys.orig/conf/NOTES	2011-06-29 15:36:10.000000000 +1000
+++ sys/conf/NOTES	2011-06-29 15:36:15.000000000 +1000
@@ -1178,20 +1178,28 @@ options 	CAPABILITIES
 # actually reducing the accuracy of operation.
 
 options 	HZ=100
 
 # Enable support for the kernel PLL to use an external PPS signal,
 # under supervision of [x]ntpd(8)
 # More info in ntpd documentation: http://www.eecis.udel.edu/~ntp
 
 options 	PPS_SYNC
 
+# Enable support for generic Feed-Forward clocks in the kernel.
+# The feed-forward clock support is an alternative to the feedback oriented
+# ntpd/system clock approach, and is to be used with a feed-forward
+# synchronization algorithm such as the RADclock:
+# More info here: http://www.synclab.org/radclock
+
+options 	FFCLOCK
+
 
 #####################################################################
 # SCSI DEVICES
 
 # SCSI DEVICE CONFIGURATION
 
 # The SCSI subsystem consists of the `base' SCSI code, a number of
 # high-level SCSI device `type' drivers, and the low-level host-adapter
 # device drivers.  The host adapters are listed in the ISA and PCI
 # device configuration sections below.
Index: sys/conf/options
===================================================================
--- sys.orig/conf/options	2011-06-29 15:36:10.000000000 +1000
+++ sys/conf/options	2011-06-29 15:36:15.000000000 +1000
@@ -69,20 +69,21 @@ COMPAT_43	opt_compat.h
 COMPAT_43TTY	opt_compat.h
 COMPAT_FREEBSD4	opt_compat.h
 COMPAT_FREEBSD5	opt_compat.h
 COMPAT_FREEBSD6	opt_compat.h
 COMPAT_FREEBSD7	opt_compat.h
 COMPILING_LINT	opt_global.h
 COMPRESS_USER_CORES opt_core.h
 CY_PCI_FASTINTR
 DEADLKRES	opt_watchdog.h
 DIRECTIO
+FFCLOCK
 FULL_PREEMPTION	opt_sched.h
 IPI_PREEMPTION	opt_sched.h
 GEOM_AES	opt_geom.h
 GEOM_BDE	opt_geom.h
 GEOM_BSD	opt_geom.h
 GEOM_CACHE	opt_geom.h
 GEOM_CONCAT	opt_geom.h
 GEOM_ELI	opt_geom.h
 GEOM_FOX	opt_geom.h
 GEOM_GATE	opt_geom.h
Index: sys/kern/kern_tc.c
===================================================================
--- sys.orig/kern/kern_tc.c	2011-06-29 15:36:10.000000000 +1000
+++ sys/kern/kern_tc.c	2011-06-29 22:40:09.000000000 +1000
@@ -1,29 +1,43 @@
 /*-
  * ----------------------------------------------------------------------------
  * "THE BEER-WARE LICENSE" (Revision 42):
  * <phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you
  * can do whatever you want with this stuff. If we meet some day, and you think
  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
  * ----------------------------------------------------------------------------
+ *
+ * Copyright (C) 2010 The University of Melbourne
+ * All rights reserved.
+ *
+ * Portions of this software were developed by the University of Melbourne
+ * under sponsorship from the FreeBSD Foundation.
  */
 
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_ffclock.h"
 #include "opt_ntp.h"
 
 #include <sys/param.h>
 #include <sys/kernel.h>
+#ifdef FFCLOCK
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#endif
 #include <sys/sysctl.h>
 #include <sys/syslog.h>
 #include <sys/systm.h>
+#ifdef FFCLOCK
+#include <sys/timeffc.h>
+#endif
 #include <sys/timepps.h>
 #include <sys/timetc.h>
 #include <sys/timex.h>
 
 /*
  * A large step happens on boot.  This constant detects such steps.
  * It is relatively small so that ntp_update_second gets called enough
  * in the typical 'missed a couple of seconds' case, but doesn't loop
  * forever when the time step is large.
  */
@@ -293,20 +307,490 @@ getmicrotime(struct timeval *tvp)
 	struct timehands *th;
 	u_int gen;
 
 	do {
 		th = timehands;
 		gen = th->th_generation;
 		*tvp = th->th_microtime;
 	} while (gen == 0 || gen != th->th_generation);
 }
 
+#ifdef FFCLOCK
+/*
+ * Support for feed-forward synchronization algorithms.
+ * This is heavily inspired by the timehands mechanism but kept independent from
+ * it. *_windup() functions have some connection to avoid accessing the
+ * timecounter hardware more than necessary.
+ */
+
+/* Feed-Forward Clock estimates kept updated by the synchronization daemon. */
+struct ffclock_estimate ffclock_estimate;
+struct bintime ffclock_boottime;
+uint8_t ffclock_fetch_update;
+struct mtx ffclock_mtx;
+
+struct fftimehands {
+	struct ffclock_estimate cest;
+	struct bintime	tick_time;
+	struct bintime	tick_time_smooth;
+	ffcounter 	tick_ffcount;
+	int64_t		smoothjump;	/* Smoothing adjustment in [ns] */
+	int32_t		smoothstep;	/* Smoothing adjustment in [ns] */
+	volatile uint8_t gen;
+	struct fftimehands *next;
+};
+
+static struct fftimehands ffth0;
+static struct fftimehands ffth1;
+static struct fftimehands ffth2;
+static struct fftimehands ffth3;
+static struct fftimehands ffth4;
+static struct fftimehands ffth5;
+static struct fftimehands ffth6;
+static struct fftimehands ffth7;
+static struct fftimehands ffth8;
+static struct fftimehands ffth9;
+
+static struct fftimehands *volatile fftimehands = &ffth0;
+
+static void
+ffclock_init(void)
+{
+	memset(&ffth0, 0, sizeof(struct fftimehands));
+	memset(&ffth1, 0, sizeof(struct fftimehands));
+	memset(&ffth2, 0, sizeof(struct fftimehands));
+	memset(&ffth3, 0, sizeof(struct fftimehands));
+	memset(&ffth4, 0, sizeof(struct fftimehands));
+	memset(&ffth5, 0, sizeof(struct fftimehands));
+	memset(&ffth6, 0, sizeof(struct fftimehands));
+	memset(&ffth7, 0, sizeof(struct fftimehands));
+	memset(&ffth8, 0, sizeof(struct fftimehands));
+	memset(&ffth9, 0, sizeof(struct fftimehands));
+	ffth0.next = &ffth1;
+	ffth1.next = &ffth2;
+	ffth2.next = &ffth3;
+	ffth3.next = &ffth4;
+	ffth4.next = &ffth5;
+	ffth5.next = &ffth6;
+	ffth6.next = &ffth7;
+	ffth7.next = &ffth8;
+	ffth8.next = &ffth9;
+	ffth9.next = &ffth0;
+	bintime_clear(&ffclock_boottime);
+	ffclock_fetch_update = 0;
+	mtx_init(&ffclock_mtx, "ffclock lock", NULL, MTX_DEF);
+}
+
+/*
+ * Reset the ffclock estimates.
+ * Called from inittodr() to get things kickstarted and uses the timecounter
+ * nominal frequency as a first period estimate.
+ * Note: this function may be called several time just after boot.
+ */
+void
+ffclock_reset_clock(struct timespec *ts)
+{
+	struct timecounter *tc;
+	struct ffclock_estimate cest;
+
+	tc = timehands->th_counter;
+	memset(&cest, 0, sizeof(struct ffclock_estimate));
+
+	timespec2bintime(ts, &(cest.boot_time));
+	cest.update_time = cest.boot_time;
+	ffclock_read_counter(&cest.update_ffcount);
+	cest.leapsec_next = 0;
+	cest.period = ((1LLU << 63) / tc->tc_frequency) << 1;
+	cest.period_shortterm = cest.period;
+	cest.error_bound_abs = 0;
+	cest.error_bound_rate = 0;
+	cest.status = 0;
+	cest.leapsec_total = 0;
+	cest.leapsec = 0;
+
+	mtx_lock(&ffclock_mtx);
+	bcopy(&cest, &ffclock_estimate, sizeof(struct ffclock_estimate));
+	ffclock_fetch_update = 1;
+	mtx_unlock(&ffclock_mtx);
+
+	printf("FFclock: %s - period = %llu (%llu Hz), time = %ld.%09lu\n",
+	    tc->tc_name,
+	    (long long unsigned) ffclock_estimate.period,
+	    (long long unsigned) tc->tc_frequency,
+	    (long) ts->tv_sec, (long unsigned) ts->tv_nsec);
+}
+
+/*
+ * Convert a time interval measured in RAW counter units to time in seconds and
+ * add it to a timestamp in bintime format. This function is used to compute
+ * absolute time and takes shortterm drift into accont.
+ */
+static void
+ffclock_absdelta_add(ffcounter ffdelta, struct bintime *bt, struct ffclock_estimate *cest)
+{
+	struct bintime period, corr, bt2;
+	ffcounter delta, delta_max;
+
+	period.sec = 0;
+	period.frac = cest->period;
+
+	/* The short term correction may be positive or negative */
+	corr.sec = 0;
+	if (cest->period_shortterm > cest->period)
+		corr.frac = cest->period_shortterm - cest->period;
+	else
+		corr.frac = cest->period - cest->period_shortterm;
+
+	/*
+	 * bintime_mul requires u_int type, but the value of the ffcounter may
+	 * be larger than the max value of u_int. Loop to consume cycles and
+	 * prevent problems.
+	 */
+	delta_max = (1LLU << (8 * sizeof(u_int))) - 1;
+	do {
+		if (ffdelta > delta_max)
+			delta = delta_max;
+		else
+			delta = ffdelta;
+
+		bt2 = period;
+		bintime_mul(&bt2, (u_int)delta);
+		bintime_add(bt, &bt2);
+
+		bt2 = corr;
+		bintime_mul(&bt2, (u_int)delta);
+		if (cest->period_shortterm > cest->period)
+			bintime_add(bt, &bt2);
+		else
+			bintime_sub(bt, &bt2);
+
+		ffdelta -= delta;
+	} while (ffdelta > 0);
+}
+
+/*
+ * Convert a time interval measured in RAW counter units to time in seconds and
+ * subtract it to a timestamp in bintime format. This function is used to
+ * compute absolute time and takes shortterm drift into accont.
+ */
+static void
+ffclock_absdelta_sub(ffcounter ffdelta, struct bintime *bt, struct ffclock_estimate *cest)
+{
+	struct bintime period, corr, bt2;
+	ffcounter delta, delta_max;
+
+	period.sec = 0;
+	period.frac = cest->period;
+
+	/* The short term correction may be positive or negative */
+	corr.sec = 0;
+	if (cest->period_shortterm > cest->period)
+		corr.frac = cest->period_shortterm - cest->period;
+	else
+		corr.frac = cest->period - cest->period_shortterm;
+
+	/*
+	 * bintime_mul requires u_int type, but the value of the ffcounter may
+	 * be larger than the max value of u_int. Loop to consume cycles and
+	 * prevent problems.
+	 */
+	delta_max = (1LLU << (8 * sizeof(u_int))) - 1;
+	do {
+		if (ffdelta > delta_max)
+			delta = delta_max;
+		else
+			delta = ffdelta;
+
+		bt2 = period;
+		bintime_mul(&bt2, (u_int)delta);
+		bintime_sub(bt, &bt2);
+
+		bt2 = corr;
+		bintime_mul(&bt2, (u_int)delta);
+		if (cest->period_shortterm > cest->period)
+			bintime_sub(bt, &bt2);
+		else
+			bintime_add(bt, &bt2);
+
+		ffdelta -= delta;
+	} while (ffdelta > 0);
+}
+
+/*
+ * Update the fftimehands.
+ *
+ * Push the tick ffcount and time(s) forward based on current clock estimate.
+ * The conversion from ffcounter to bintime relies on the difference clock
+ * principle, whose accuracy relies on computing small time intervals. Also
+ * update the smoothing correction on each tick.
+ *
+ * If a new clock estimate has been passed by the synchronisation daemon, make
+ * it current, and compute the new smoothing correction with this new update.
+ */
+static void
+ffclock_windup(u_int delta)
+{
+	struct ffclock_estimate *cest;
+	struct fftimehands *ffth;
+	struct bintime bt;
+	ffcounter ffdelta;
+	uint64_t nsec;
+	uint8_t ogen;
+
+	/*
+	 * Pick the next timehand, copy current ffclock estimates and move tick
+	 * times and counter forward.
+	 */
+	ffth = fftimehands->next;
+	ogen = ffth->gen;
+	ffth->gen = 0;
+	cest = &(ffth->cest);
+	ffdelta = (ffcounter)delta;
+	bcopy(&(fftimehands->cest), cest, sizeof(struct ffclock_estimate));
+	ffth->tick_time = fftimehands->tick_time;
+	ffth->tick_time_smooth = fftimehands->tick_time_smooth;
+	ffclock_absdelta_add(ffdelta, &(ffth->tick_time), cest);
+	ffclock_absdelta_add(ffdelta, &(ffth->tick_time_smooth), cest);
+	ffth->tick_ffcount = fftimehands->tick_ffcount + ffdelta;
+
+	/*
+	 * Adjust the (signed) smoothing correction to bring it to zero and update
+	 * the smoothed tick time accordingly
+	 */
+	ffth->smoothjump = fftimehands->smoothjump;
+	ffth->smoothstep = fftimehands->smoothstep;
+
+	if ((ffth->smoothjump < 0) && (ffth->smoothjump > ffth->smoothstep))
+		ffth->smoothjump = 0;
+	if ((ffth->smoothjump > 0) && (ffth->smoothjump < ffth->smoothstep))
+		ffth->smoothjump = 0;
+
+	if (ffth->smoothjump != 0) {
+		ffth->smoothjump -= ffth->smoothstep;
+		nsec = (uint64_t)(ffth->smoothjump - (ffth->smoothjump / 1000000000LL) * 1000000000LL);
+		nsec *= (uint64_t)18446744073LL;
+
+		if (ffth->smoothjump > 0)
+			bintime_subx(&ffth->tick_time_smooth, nsec);
+		else
+			bintime_addx(&ffth->tick_time_smooth, nsec);
+		ffth->tick_time_smooth.sec -= (ffth->smoothjump / 1000000000LL) * 1000000000LL;
+	}
+
+	/*
+	 * If available, grab updated clock estimates and make them current.
+	 * Recompute tick_time based on the updated estimates and update smoothing
+	 * correction.
+	 */
+	if (ffclock_fetch_update) {
+		bcopy(&ffclock_estimate, cest, sizeof(struct ffclock_estimate));
+		ffclock_boottime = cest->boot_time;
+		ffdelta = ffth->tick_ffcount - cest->update_ffcount;
+		ffth->tick_time = cest->update_time;
+		ffclock_absdelta_add(ffdelta, &(ffth->tick_time), cest);
+
+		/*
+		 * Compute parameters of smoothed (monotonic) Feed-Forward Clock.
+		 * The ffclock time is smoothed over a flooring of the polling
+		 * period of the synchronisation algorithm, which should be mild. Note
+		 * there may be some adjustment remaining from previous update if the
+		 * system missed a few hardclock ticks.
+		 *
+		 * NOTE: The difference between smoothed time and ffclock time may be
+		 * negative (and very small), so cannot use struct bintime here.
+		 *
+		 * NOTE: The rate of smoothing is capped at 5000PPM, which is 5ms/s or
+		 * 18s/hour. We do now want the smoothed clock to take more than an hour
+		 * to converge. If the jump is greater than 18s, resets smoothed time,
+		 * which should only happen when the sync algorithm starts only. Most
+		 * cristals have a drift smaller than 1PPM and would then take over 200
+		 * days to accumulate 18s of error.
+		 */
+		ffth->smoothjump = (ffth->tick_time_smooth.sec - ffth->tick_time.sec) * 1000000000LL;
+		ffth->smoothjump += ((uint64_t)1000000000LL * (uint32_t)(ffth->tick_time_smooth.frac >> 32)) >> 32;
+		ffth->smoothjump -= ((uint64_t)1000000000LL * (uint32_t)(ffth->tick_time.frac >> 32)) >> 32;
+		ffth->smoothjump += ffth->smoothjump;
+		if ((ffth->smoothjump > 1800000000LL) || (ffth->smoothjump < -1800000000LL))
+			ffth->smoothjump = 0;
+
+		ffdelta = cest->update_ffcount - fftimehands->cest.update_ffcount;
+		ffclock_convert_diff(ffdelta, &bt);
+		/* If clock has been reset, no good estimate. Default to small polling period */
+		if (bt.sec == 0)
+			bt.sec = 16;
+		ffth->smoothstep = ffth->smoothjump / bt.sec / hz;
+
+		if (ffth->smoothstep > (5000000 / hz))
+			ffth->smoothstep = 5000000;
+
+		ffclock_fetch_update = 0;
+	}
+	if (++ogen == 0)
+		ogen = 1;
+	ffth->gen = ogen;
+	fftimehands = ffth;
+}
+
+/*
+ * Adjust the fftimehands when the timecounter is changed.
+ * This is a fairly radical operation for a feed-forward synchronization daemon.
+ * The best thing may be to trigger a restart?
+ * XXX Time in second is preserved here, but tick_ffcount is effectively wrong
+ * since tc_windup() changed th_offset_count to ncount. This results in a jump
+ * next time ffdelta is computed ... still thinking about the best strategy.
+ */
+static void
+ffclock_change_tc(struct timehands *th, u_int ncount)
+{
+	struct fftimehands *ffth;
+	struct ffclock_estimate *cest;
+	uint8_t ogen;
+
+	ffth = fftimehands->next;
+	ogen = ffth->gen;
+	ffth->gen = 0;
+
+	cest = &(ffth->cest);
+	bcopy(&(fftimehands->cest), cest, sizeof(struct ffclock_estimate));
+	ffth->tick_time = fftimehands->tick_time;
+
+	// TODO take ncount into account here?
+	ffth->tick_ffcount = fftimehands->tick_ffcount;
+
+	cest->period = ((1LLU << 63) / th->th_counter->tc_frequency ) << 1;
+	cest->period_shortterm = cest->period;
+	cest->error_bound_abs = 0;
+	cest->error_bound_rate = 0;
+	cest->status = 0;
+
+	if (++ogen == 0)
+		ogen = 1;
+	ffth->gen = ogen;
+	fftimehands = ffth;
+}
+
+/*
+ * Retrieve feed-forward counter and time of last kernel tick
+ */
+void
+ffclock_last_tick(ffcounter *ffcount, struct bintime *bt, uint32_t flags)
+{
+	struct fftimehands *ffth;
+	uint8_t gen;
+
+	/*
+	 * No locking but check generation has not changed. Also need to make sure
+	 * ffdelta is positive, ie. ffcount > tick_ffcount
+	 */
+	do {
+		ffth = fftimehands;
+		gen = ffth->gen;
+		if ((flags & FFCLOCK_SMOOTH) == FFCLOCK_SMOOTH)
+			*bt = ffth->tick_time_smooth;
+		else
+			*bt = ffth->tick_time;
+		*ffcount = ffth->tick_ffcount;
+	} while (gen == 0 || gen != ffth->gen);
+}
+
+/*
+ * Convert ffcounter to bintime using current ffclock estimate. If error_bound
+ * not NULL, an upper bound on absolute time error is reported in nanoseconds.
+ * Note, this is a non-causal absolute clock.
+ * TODO: make a causal version (parameter option?)
+ * XXX TODO Guarantee that ffdelta is +ve???
+ */
+void
+ffclock_convert_abs(ffcounter ffcount, struct bintime *bt, uint32_t flags)
+{
+	struct fftimehands *ffth;
+	uint8_t gen;
+
+	/*
+	 * No locking but check generation has not changed. Also need to make sure
+	 * ffdelta is positive, ie. ffcount > tick_ffcount
+	 */
+	do {
+		ffth = fftimehands;
+		gen = ffth->gen;
+		if ((flags & FFCLOCK_SMOOTH) == FFCLOCK_SMOOTH)
+			*bt = ffth->tick_time_smooth;
+		else
+			*bt = ffth->tick_time;
+
+		if (ffcount > ffth->tick_ffcount)
+			ffclock_absdelta_add(ffcount - ffth->tick_ffcount, bt, &(ffth->cest));
+		else
+			ffclock_absdelta_sub(ffth->tick_ffcount - ffcount, bt, &(ffth->cest));
+	} while (gen == 0 || gen != ffth->gen);
+}
+
+/*
+ * Convert a time interval measure in RAW counter units into seconds. This is
+ * the difference clock operation that allows measuring small intervals
+ * reliably, without taking counter drift into account.
+ */
+void
+ffclock_convert_diff(ffcounter ffdelta, struct bintime *bt)
+{
+	struct fftimehands *ffth;
+	struct bintime delta;
+	ffcounter delta_max;
+	uint8_t gen;
+
+	/* No locking but check generation has not changed. */
+	delta_max = (1LLU << (8 * sizeof(u_int))) - 1;
+	do {
+		ffth = fftimehands;
+		gen = ffth->gen;
+		bt->sec = 0;
+		bt->frac = 0;
+
+		while (ffdelta > delta_max) {
+			delta.sec = 0;
+			delta.frac = ffth->cest.period;
+			bintime_mul(&delta, (u_int)delta_max);
+			bintime_add(bt, &delta);
+			ffdelta -= delta_max;
+		}
+		delta.sec = 0;
+		delta.frac = ffth->cest.period;
+		bintime_mul(&delta, ffdelta);
+		bintime_add(bt, &delta);
+	} while (gen == 0 || gen != ffth->gen);
+}
+
+/* Return current ffcounter value */
+void
+ffclock_read_counter(ffcounter *ffcount)
+{
+	struct timehands *th;
+	struct fftimehands *ffth;
+	u_int gen, delta;
+
+	/*
+	 * ffclock_windup() called from tc_windup(), safe to rely on
+	 * th->th_generation only, for correct delta and ffcounter.
+	 */
+	do {
+		th = timehands;
+		gen = th->th_generation;
+		ffth = fftimehands;
+		delta = tc_delta(th);
+		*ffcount = ffth->tick_ffcount;
+	} while (gen == 0 || gen != th->th_generation);
+
+	*ffcount += delta;
+}
+#endif /* FFCLOCK */
+
+
 /*
  * Initialize a new timecounter and possibly use it.
  */
 void
 tc_init(struct timecounter *tc)
 {
 	u_int u;
 	struct sysctl_oid *tc_root;
 
 	u = tc->tc_frequency / tc->tc_counter_mask;
@@ -433,20 +917,23 @@ tc_windup(void)
 	/*
 	 * Capture a timecounter delta on the current timecounter and if
 	 * changing timecounters, a counter value from the new timecounter.
 	 * Update the offset fields accordingly.
 	 */
 	delta = tc_delta(th);
 	if (th->th_counter != timecounter)
 		ncount = timecounter->tc_get_timecount(timecounter);
 	else
 		ncount = 0;
+#ifdef FFCLOCK
+	ffclock_windup(delta);
+#endif
 	th->th_offset_count += delta;
 	th->th_offset_count &= th->th_counter->tc_counter_mask;
 	while (delta > th->th_counter->tc_frequency) {
 		/* Eat complete unadjusted seconds. */
 		delta -= th->th_counter->tc_frequency;
 		th->th_offset.sec++;
 	}
 	if ((delta > th->th_counter->tc_frequency / 2) &&
 	    (th->th_scale * delta < ((uint64_t)1 << 63))) {
 		/* The product th_scale * delta just barely overflows. */
@@ -489,20 +976,23 @@ tc_windup(void)
 	/* XXX shouldn't do this here.  Should force non-`get' versions. */
 	bintime2timeval(&bt, &th->th_microtime);
 	bintime2timespec(&bt, &th->th_nanotime);
 
 	/* Now is a good time to change timecounters. */
 	if (th->th_counter != timecounter) {
 		th->th_counter = timecounter;
 		th->th_offset_count = ncount;
 		tc_min_ticktock_freq = max(1, timecounter->tc_frequency /
 		    (((uint64_t)timecounter->tc_counter_mask + 1) / 3));
+#ifdef FFCLOCK
+		ffclock_change_tc(th, ncount);
+#endif
 	}
 
 	/*-
 	 * Recalculate the scaling factor.  We want the number of 1/2^64
 	 * fractions of a second per period of the hardware counter, taking
 	 * into account the th_adjustment factor which the NTP PLL/adjtime(2)
 	 * processing provides us with.
 	 *
 	 * The th_adjustment is nanoseconds per second with 32 bit binary
 	 * fraction and we want 64 bit binary fraction of second:
@@ -807,20 +1297,23 @@ inittimecounter(void *dummy)
 	 * smallest reasonable one.  If they want better timestamps they
 	 * should use the non-"get"* functions.
 	 */
 	if (hz > 1000)
 		tc_tick = (hz + 500) / 1000;
 	else
 		tc_tick = 1;
 	p = (tc_tick * 1000000) / hz;
 	printf("Timecounters tick every %d.%03u msec\n", p / 1000, p % 1000);
 
+#ifdef FFCLOCK
+	ffclock_init();
+#endif
 	/* warm up new timecounter (again) and get rolling. */
 	(void)timecounter->tc_get_timecount(timecounter);
 	(void)timecounter->tc_get_timecount(timecounter);
 	tc_windup();
 }
 
 SYSINIT(timecounter, SI_SUB_CLOCKS, SI_ORDER_SECOND, inittimecounter, NULL);
 
 /* Cpu tick handling -------------------------------------------------*/
 
Index: sys/kern/subr_rtc.c
===================================================================
--- sys.orig/kern/subr_rtc.c	2011-06-29 15:36:10.000000000 +1000
+++ sys/kern/subr_rtc.c	2011-06-29 15:36:15.000000000 +1000
@@ -53,20 +53,25 @@ __FBSDID("$FreeBSD$");
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/kernel.h>
 #include <sys/bus.h>
 #include <sys/clock.h>
 #include <sys/sysctl.h>
 #include <sys/timetc.h>
 
 #include "clock_if.h"
 
+#include "opt_ffclock.h"
+#ifdef FFCLOCK
+#include <sys/timeffc.h>
+#endif
+
 static device_t clock_dev = NULL;
 static long clock_res;
 static struct timespec clock_adj;
 
 /* XXX: should be kern. now, it's no longer machdep.  */
 static int disable_rtc_set;
 SYSCTL_INT(_machdep, OID_AUTO, disable_rtc_set, CTLFLAG_RW, &disable_rtc_set,
     0, "Disallow adjusting time-of-day clock");
 
 void
@@ -126,20 +131,23 @@ inittodr(time_t base)
 	}
 	if (error == EINVAL || ts.tv_sec < 0) {
 		printf("Invalid time in real time clock.\n"
 		    "Check and reset the date immediately!\n");
 		goto wrong_time;
 	}
 
 	ts.tv_sec += utc_offset();
 	timespecadd(&ts, &clock_adj);
 	tc_setclock(&ts);
+#ifdef FFCLOCK
+	ffclock_reset_clock(&ts);
+#endif
 	return;
 
 wrong_time:
 	if (base > 0) {
 		ts.tv_sec = base;
 		ts.tv_nsec = 0;
 		tc_setclock(&ts);
 	}
 }
 
Index: sys/sys/_ffcounter.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sys/sys/_ffcounter.h	2011-06-29 15:36:15.000000000 +1000
@@ -0,0 +1,43 @@
+/*-
+ * Copyright (C) 2010 University of Melbourne
+ * All rights reserved.
+ *
+ * This software was developed by the University of Melbourne under sponsorship
+ * from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYS__FFCOUNTER_H_
+#define _SYS__FFCOUNTER_H_
+
+#include <sys/types.h>
+
+/*
+ * Feed-forward Clock counter
+ * The fundamental element of a feed-forward clock is a wide monotonically
+ * increasing counter that accumulates at the same rate as the selected
+ * timecounter.
+ */
+typedef uint64_t ffcounter;
+
+#endif /* _SYS__FFCOUNTER_H_ */
Index: sys/sys/timeffc.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sys/sys/timeffc.h	2011-06-29 22:34:21.000000000 +1000
@@ -0,0 +1,98 @@
+/*-
+ * Copyright (C) 2010 University of Melbourne
+ * All rights reserved.
+ *
+ * This software was developed by the University of Melbourne under sponsorship
+ * from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYS_TIMEFF_H_
+#define _SYS_TIMEFF_H_
+
+#include <sys/_ffcounter.h>
+#include <sys/time.h>
+
+/*
+ * Feed-Forward Clock estimate
+ * Holds time mark as a ffcounter and conversion to bintime based on current
+ * timecounter period and offset estimate passed by the synchronization daemon.
+ * Provides time of last daemon update, clock status and bound on error.
+ */
+struct ffclock_estimate {
+	struct bintime	boot_time;		/* Boot time */
+	struct bintime	update_time;	/* Time of last update */
+	ffcounter	update_ffcount;		/* Counter value of estimates last update */
+	ffcounter	leapsec_next;		/* Counter value of next leap second */
+	uint64_t	period;				/* Long-term estimate of counter period */
+	uint64_t	period_shortterm;	/* Short-term estimate of counter period */
+	uint32_t	error_bound_abs;	/* Bound on absolute clock error [ns] */
+	uint32_t	error_bound_rate;	/* Bound on counter rate error [ps/s] */
+	uint32_t	status;				/* Clock status */
+	int16_t		leapsec_total;		/* All leap seconds seen so far */
+	int8_t		leapsec;			/* Next leap second, usually in {-1,0,1} */
+};
+
+#if __BSD_VISIBLE
+#ifdef _KERNEL
+
+/*
+ * Clock flags to select how the Feed-Forward counter is converted to
+ * time in seconds.
+ * FAST:	do not read the hardware counter, returns time of last tick. The
+ * 			time returned as the resolution of the kernel tick (1/hz [s]).
+ * SMOOTH:	smoothes clock and prevent it from going backward (monotonic).
+ * 			Slightly less accurate and may take time to converge.
+ * LEAPSEC: returns UTC time, including leap seconds.
+ */
+#define FFCLOCK_FAST		1
+#define FFCLOCK_SMOOTH		2
+#define FFCLOCK_LEAPSEC		4
+
+/* Resets Feed-Forward clock from RTC */
+void ffclock_reset_clock(struct timespec *ts);
+
+/*
+ * Return the current value of the Feed-Forward Clock counter. Essential to
+ * measure time interval in counter units. If a fast timecounter is used by the
+ * system, may also allow fast but accurate timestamping.
+ */
+void ffclock_read_counter(ffcounter *ffcount);
+
+/*
+ * Retrieve feed-forward counter value and time of last kernel tick. This
+ * accepts the FFCLOCK_SMOOTH flag.
+ */
+void ffclock_last_tick(ffcounter *ffcount, struct bintime *bt, uint32_t flags);
+
+/*
+ * Low level routines to convert a counter timestamp into absolute time and a
+ * counter timestamp interval into interval in seconds. The absolute time
+ * conversion accepts the FFCLOCK_SMOOTH flag.
+ */
+void ffclock_convert_abs(ffcounter ffcount, struct bintime *bt, uint32_t flags);
+void ffclock_convert_diff(ffcounter ffdelta, struct bintime *bt);
+
+#endif /* _KERNEL */
+#endif /* __BSD_VISIBLE */
+#endif /* _SYS_TIMEFF_H */
