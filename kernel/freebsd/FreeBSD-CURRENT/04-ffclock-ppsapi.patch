Modification to the PPS-API to support ffcounter timestamps

---
 kern/kern_tc.c |   41 +++++++++++++++++++++++++++++++++++
 sys/timepps.h  |   65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 106 insertions(+)

Index: sys/kern/kern_tc.c
===================================================================
--- sys.orig/kern/kern_tc.c	2010-12-23 00:13:53.000000000 +1100
+++ sys/kern/kern_tc.c	2010-12-23 00:21:48.000000000 +1100
@@ -845,6 +845,9 @@ pps_ioctl(u_long cmd, caddr_t data, stru
 {
 	pps_params_t *app;
 	struct pps_fetch_args *fapi;
+#ifdef FFCLOCK
+	struct ffclock_pps_fetch_args *ffclock_fapi;
+#endif
 #ifdef PPS_SYNC
 	struct pps_kcbind_args *kapi;
 #endif
@@ -878,6 +881,17 @@ pps_ioctl(u_long cmd, caddr_t data, stru
 		pps->ppsinfo.current_mode = pps->ppsparam.mode;
 		fapi->pps_info_buf = pps->ppsinfo;
 		return (0);
+#ifdef FFCLOCK
+	case FFCLOCK_PPS_IOC_FETCH:
+		ffclock_fapi = (struct ffclock_pps_fetch_args *)data;
+		if (ffclock_fapi->tsformat && ffclock_fapi->tsformat != PPS_TSFMT_TSPEC)
+			return (EINVAL);
+		if (ffclock_fapi->timeout.tv_sec || ffclock_fapi->timeout.tv_nsec)
+			return (EOPNOTSUPP);
+		pps->ppsinfo.current_mode = pps->ppsparam.mode;
+		ffclock_fapi->pps_info_buf = pps->ffclock_ppsinfo;
+		return (0);
+#endif 	/* FFCLOCK */
 	case PPS_IOC_KCBIND:
 #ifdef PPS_SYNC
 		kapi = (struct pps_kcbind_args *)data;
@@ -917,6 +931,9 @@ pps_capture(struct pps_state *pps)
 	th = timehands;
 	pps->capgen = th->th_generation;
 	pps->capth = th;
+#ifdef FFCLOCK
+	pps->capffth = fftimehands;
+#endif
 	pps->capcount = th->th_counter->tc_get_timecount(th->th_counter);
 	if (pps->capgen != th->th_generation)
 		pps->capgen = 0;
@@ -930,6 +947,12 @@ pps_event(struct pps_state *pps, int eve
 	u_int tcount, *pcount;
 	int foff, fhard;
 	pps_seq_t *pseq;
+#ifdef FFCLOCK
+	struct timespec *ffclock_tsp;
+	pps_seq_t *ffclock_pseq;
+	ffcounter_t *ffcounter;
+	ffcounter_t ffcounter_mark;
+#endif
 
 	KASSERT(pps != NULL, ("NULL pps pointer in pps_event"));
 	/* If the timecounter was wound up underneath us, bail out. */
@@ -944,6 +967,11 @@ pps_event(struct pps_state *pps, int eve
 		fhard = pps->kcmode & PPS_CAPTUREASSERT;
 		pcount = &pps->ppscount[0];
 		pseq = &pps->ppsinfo.assert_sequence;
+#ifdef FFCLOCK
+		ffcounter = &pps->ffclock_ppsinfo.assert_ffcounter;
+		ffclock_tsp = &pps->ffclock_ppsinfo.assert_timestamp;
+		ffclock_pseq = &pps->ffclock_ppsinfo.assert_sequence;
+#endif
 	} else {
 		tsp = &pps->ppsinfo.clear_timestamp;
 		osp = &pps->ppsparam.clear_offset;
@@ -951,6 +979,11 @@ pps_event(struct pps_state *pps, int eve
 		fhard = pps->kcmode & PPS_CAPTURECLEAR;
 		pcount = &pps->ppscount[1];
 		pseq = &pps->ppsinfo.clear_sequence;
+#ifdef FFCLOCK
+		ffcounter = &pps->ffclock_ppsinfo.clear_ffcounter;
+		ffclock_tsp = &pps->ffclock_ppsinfo.clear_timestamp;
+		ffclock_pseq = &pps->ffclock_ppsinfo.clear_sequence;
+#endif
 	}
 
 	/*
@@ -967,6 +1000,9 @@ pps_event(struct pps_state *pps, int eve
 	/* Convert the count to a timespec. */
 	tcount = pps->capcount - pps->capth->th_offset_count;
 	tcount &= pps->capth->th_counter->tc_counter_mask;
+#ifdef FFCLOCK
+	ffcounter_mark = pps->capffth->ffcounter_mark;
+#endif
 	bt = pps->capth->th_offset;
 	bintime_addx(&bt, pps->capth->th_scale * tcount);
 	bintime_add(&bt, &boottimebin);
@@ -979,6 +1015,11 @@ pps_event(struct pps_state *pps, int eve
 	*pcount = pps->capcount;
 	(*pseq)++;
 	*tsp = ts;
+#ifdef FFCLOCK
+	(*ffclock_pseq)++;
+	*ffclock_tsp = ts;
+	*ffcounter = (ffcounter_mark + tcount);
+#endif
 
 	if (foff) {
 		timespecadd(tsp, osp);
Index: sys/sys/timepps.h
===================================================================
--- sys.orig/sys/timepps.h	2010-12-22 20:48:42.000000000 +1100
+++ sys/sys/timepps.h	2010-12-23 00:21:54.000000000 +1100
@@ -6,6 +6,12 @@
  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
  * ----------------------------------------------------------------------------
  *
+ * Copyright (C) 2010 The University of Melbourne
+ * All rights reserved.
+ *
+ * Portions of this software were developed by the University of Melbourne
+ * under sponsorship from the FreeBSD Foundation.
+ *
  * $FreeBSD: src/sys/sys/timepps.h,v 1.19 2005/01/07 02:29:24 imp Exp $
  *
  * The is a FreeBSD version of the RFC 2783 API for Pulse Per Second 
@@ -15,6 +21,8 @@
 #ifndef _SYS_TIMEPPS_H_
 #define _SYS_TIMEPPS_H_
 
+#include "opt_ffclock.h"
+
 #include <sys/ioccom.h>
 #include <sys/time.h>
 
@@ -43,12 +51,34 @@ typedef struct {
 	int		current_mode;		/* current mode bits */
 } pps_info_t;
 
+
+#ifdef FFCLOCK
+typedef union pps_ffcounteru {
+	ffcounter_t ffcounter;
+} pps_ffcounteru_t;
+
+typedef struct {
+	pps_seq_t	assert_sequence;	/* assert event seq # */
+	pps_seq_t	clear_sequence;		/* clear event seq # */
+	pps_timeu_t	assert_tu;
+	pps_timeu_t	clear_tu;
+	int		current_mode;		/* current mode bits */
+	pps_ffcounteru_t  assert_vcu;
+	pps_ffcounteru_t  clear_vcu;
+} ffclock_pps_info_t;
+#endif	/* FFCLOCK */
+
 #define assert_timestamp        assert_tu.tspec
 #define clear_timestamp         clear_tu.tspec
 
 #define assert_timestamp_ntpfp  assert_tu.ntpfp
 #define clear_timestamp_ntpfp   clear_tu.ntpfp
 
+#ifdef FFCLOCK
+#define assert_ffcounter	assert_vcu.ffcounter
+#define clear_ffcounter		clear_vcu.ffcounter
+#endif 	/* FFCLOCK */
+
 typedef struct {
 	int api_version;			/* API version # */
 	int mode;				/* mode bits */
@@ -89,6 +119,14 @@ struct pps_fetch_args {
 	struct timespec	timeout;
 };
 
+#ifdef FFCLOCK
+struct ffclock_pps_fetch_args {
+	int tsformat;
+	ffclock_pps_info_t	pps_info_buf;
+	struct timespec	timeout;
+};
+#endif	/* FFCLOCK */
+
 struct pps_kcbind_args {
 	int kernel_consumer;
 	int edge;
@@ -102,6 +140,9 @@ struct pps_kcbind_args {
 #define PPS_IOC_GETCAP		_IOR('1', 5, int)
 #define PPS_IOC_FETCH		_IOWR('1', 6, struct pps_fetch_args)
 #define PPS_IOC_KCBIND		_IOW('1', 7, struct pps_kcbind_args)
+#ifdef FFCLOCK
+#define FFCLOCK_PPS_IOC_FETCH		_IOWR('1', 8, struct ffclock_pps_fetch_args)
+#endif 	/* FFCLOCK */
 
 #ifdef _KERNEL
 
@@ -118,6 +159,10 @@ struct pps_state {
 	int		ppscap;
 	struct timecounter *ppstc;
 	unsigned	ppscount[3];
+#ifdef FFCLOCK
+	ffclock_pps_info_t	ffclock_ppsinfo;
+	struct fftimehands *capffth;
+#endif 	/* FFCLOCK */
 };
 
 void pps_capture(struct pps_state *pps);
@@ -183,6 +228,26 @@ time_pps_fetch(pps_handle_t handle, cons
 	return (error);
 }
 
+#ifdef FFCLOCK
+static __inline int
+ffclock_pps_fetch(pps_handle_t handle, const int tsformat,
+	ffclock_pps_info_t *ppsinfobuf, const struct timespec *timeout)
+{
+	int error;
+	struct ffclock_pps_fetch_args arg;
+
+	arg.tsformat = tsformat;
+	if (timeout == NULL) {
+		arg.timeout.tv_sec = -1;
+		arg.timeout.tv_nsec = -1;
+	} else
+		arg.timeout = *timeout;
+	error = ioctl(handle, FFCLOCK_PPS_IOC_FETCH, &arg);
+	*ppsinfobuf = arg.pps_info_buf;
+	return (error);
+}
+#endif 	/* FFCLOCK */
+
 static __inline int
 time_pps_kcbind(pps_handle_t handle, const int kernel_consumer,
 	const int edge, const int tsformat)
