Feed-forward clock and PPS-API.

Add timestamping of Pulse-Per-Second using raw ffcounter and corresponding
ffclock time in second.
Add IOCTL to retrieve ffclock timestamps from userland.

---
 kern/kern_tc.c |   42 ++++++++++++++++++++++++++++++++++++++++++
 sys/timepps.h  |   45 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 87 insertions(+)

Index: sys/kern/kern_tc.c
===================================================================
--- sys.orig/kern/kern_tc.c	2011-07-14 13:33:01.000000000 +1000
+++ sys/kern/kern_tc.c	2011-07-14 15:37:10.000000000 +1000
@@ -1340,20 +1340,23 @@ SYSCTL_PROC(_kern_timecounter, OID_AUTO,
 
 /*
  * RFC 2783 PPS-API implementation.
  */
 
 int
 pps_ioctl(u_long cmd, caddr_t data, struct pps_state *pps)
 {
 	pps_params_t *app;
 	struct pps_fetch_args *fapi;
+#ifdef FFCLOCK
+	struct ffclock_pps_fetch_args *ffclock_fapi;
+#endif
 #ifdef PPS_SYNC
 	struct pps_kcbind_args *kapi;
 #endif
 
 	KASSERT(pps != NULL, ("NULL pps pointer in pps_ioctl"));
 	switch (cmd) {
 	case PPS_IOC_CREATE:
 		return (0);
 	case PPS_IOC_DESTROY:
 		return (0);
@@ -1373,20 +1376,32 @@ pps_ioctl(u_long cmd, caddr_t data, stru
 		return (0);
 	case PPS_IOC_FETCH:
 		fapi = (struct pps_fetch_args *)data;
 		if (fapi->tsformat && fapi->tsformat != PPS_TSFMT_TSPEC)
 			return (EINVAL);
 		if (fapi->timeout.tv_sec || fapi->timeout.tv_nsec)
 			return (EOPNOTSUPP);
 		pps->ppsinfo.current_mode = pps->ppsparam.mode;
 		fapi->pps_info_buf = pps->ppsinfo;
 		return (0);
+#ifdef FFCLOCK
+	case PPS_IOC_FETCH_FFCLOCK:
+		ffclock_fapi = (struct ffclock_pps_fetch_args *)data;
+		if ((ffclock_fapi->tsformat && ffclock_fapi->tsformat) !=
+		    PPS_TSFMT_TSPEC)
+			return (EINVAL);
+		if (ffclock_fapi->timeout.tv_sec || ffclock_fapi->timeout.tv_nsec)
+			return (EOPNOTSUPP);
+		pps->ppsinfo.current_mode = pps->ppsparam.mode;
+		ffclock_fapi->pps_info_buf = pps->ffclock_ppsinfo;
+		return (0);
+#endif /* FFCLOCK */
 	case PPS_IOC_KCBIND:
 #ifdef PPS_SYNC
 		kapi = (struct pps_kcbind_args *)data;
 		/* XXX Only root should be able to do this */
 		if (kapi->tsformat && kapi->tsformat != PPS_TSFMT_TSPEC)
 			return (EINVAL);
 		if (kapi->kernel_consumer != PPS_KC_HARDPPS)
 			return (EINVAL);
 		if (kapi->edge & ~pps->ppscap)
 			return (EINVAL);
@@ -1410,56 +1425,74 @@ pps_init(struct pps_state *pps)
 		pps->ppscap |= PPS_OFFSETCLEAR;
 }
 
 void
 pps_capture(struct pps_state *pps)
 {
 	struct timehands *th;
 
 	KASSERT(pps != NULL, ("NULL pps pointer in pps_capture"));
 	th = timehands;
+#ifdef FFCLOCK
+	pps->capffth = fftimehands;
+#endif
 	pps->capgen = th->th_generation;
 	pps->capth = th;
 	pps->capcount = th->th_counter->tc_get_timecount(th->th_counter);
 	if (pps->capgen != th->th_generation)
 		pps->capgen = 0;
 }
 
 void
 pps_event(struct pps_state *pps, int event)
 {
 	struct bintime bt;
 	struct timespec ts, *tsp, *osp;
 	u_int tcount, *pcount;
 	int foff, fhard;
 	pps_seq_t *pseq;
+#ifdef FFCLOCK
+	struct timespec *ffclock_tsp;
+	pps_seq_t *ffclock_pseq;
+	ffcounter *ffcount;
+#endif
 
 	KASSERT(pps != NULL, ("NULL pps pointer in pps_event"));
 	/* If the timecounter was wound up underneath us, bail out. */
 	if (pps->capgen == 0 || pps->capgen != pps->capth->th_generation)
 		return;
 
 	/* Things would be easier with arrays. */
 	if (event == PPS_CAPTUREASSERT) {
 		tsp = &pps->ppsinfo.assert_timestamp;
 		osp = &pps->ppsparam.assert_offset;
 		foff = pps->ppsparam.mode & PPS_OFFSETASSERT;
 		fhard = pps->kcmode & PPS_CAPTUREASSERT;
 		pcount = &pps->ppscount[0];
 		pseq = &pps->ppsinfo.assert_sequence;
+#ifdef FFCLOCK
+		ffcount = &pps->ffclock_ppsinfo.assert_ffcount;
+		ffclock_tsp = &pps->ffclock_ppsinfo.assert_timestamp;
+		ffclock_pseq = &pps->ffclock_ppsinfo.assert_sequence;
+#endif
 	} else {
 		tsp = &pps->ppsinfo.clear_timestamp;
 		osp = &pps->ppsparam.clear_offset;
 		foff = pps->ppsparam.mode & PPS_OFFSETCLEAR;
 		fhard = pps->kcmode & PPS_CAPTURECLEAR;
 		pcount = &pps->ppscount[1];
 		pseq = &pps->ppsinfo.clear_sequence;
+#ifdef FFCLOCK
+		ffcount = &pps->ffclock_ppsinfo.clear_ffcount;
+		ffclock_tsp = &pps->ffclock_ppsinfo.clear_timestamp;
+		ffclock_pseq = &pps->ffclock_ppsinfo.clear_sequence;
+#endif
 	}
 
 	/*
 	 * If the timecounter changed, we cannot compare the count values, so
 	 * we have to drop the rest of the PPS-stuff until the next event.
 	 */
 	if (pps->ppstc != pps->capth->th_counter) {
 		pps->ppstc = pps->capth->th_counter;
 		*pcount = pps->capcount;
 		pps->ppscount[2] = pps->capcount;
@@ -1474,20 +1507,29 @@ pps_event(struct pps_state *pps, int eve
 	bintime_add(&bt, &boottimebin);
 	bintime2timespec(&bt, &ts);
 
 	/* If the timecounter was wound up underneath us, bail out. */
 	if (pps->capgen != pps->capth->th_generation)
 		return;
 
 	*pcount = pps->capcount;
 	(*pseq)++;
 	*tsp = ts;
+#ifdef FFCLOCK
+	*ffcount = (pps->capffth->tick_ffcount + tcount);
+	bt = pps->capffth->tick_time;
+	ffclock_convert_delta(tcount, pps->capffth->cest.period, &bt);
+	bintime_add(&bt, &(pps->capffth->tick_time));
+	bintime2timespec(&bt, &ts);
+	*ffclock_tsp = ts;
+	(*ffclock_pseq)++;
+#endif
 
 	if (foff) {
 		timespecadd(tsp, osp);
 		if (tsp->tv_nsec < 0) {
 			tsp->tv_nsec += 1000000000;
 			tsp->tv_sec -= 1;
 		}
 	}
 #ifdef PPS_SYNC
 	if (fhard) {
Index: sys/sys/timepps.h
===================================================================
--- sys.orig/sys/timepps.h	2011-07-14 10:49:19.000000000 +1000
+++ sys/sys/timepps.h	2011-07-14 14:47:40.000000000 +1000
@@ -1,18 +1,24 @@
 /*-
  * ----------------------------------------------------------------------------
  * "THE BEER-WARE LICENSE" (Revision 42):
  * <phk@FreeBSD.org> wrote this file.  As long as you retain this notice you
  * can do whatever you want with this stuff. If we meet some day, and you think
  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
  * ----------------------------------------------------------------------------
  *
+ * Copyright (C) 2010 The University of Melbourne
+ * All rights reserved.
+ *
+ * Portions of this software were developed by the University of Melbourne
+ * under sponsorship from the FreeBSD Foundation.
+ *
  * $FreeBSD$
  *
  * The is a FreeBSD version of the RFC 2783 API for Pulse Per Second 
  * timing interfaces.  
  */
 
 #ifndef _SYS_TIMEPPS_H_
 #define _SYS_TIMEPPS_H_
 
 #include <sys/ioccom.h>
@@ -43,20 +49,30 @@ typedef struct {
 	int		current_mode;		/* current mode bits */
 } pps_info_t;
 
 #define assert_timestamp        assert_tu.tspec
 #define clear_timestamp         clear_tu.tspec
 
 #define assert_timestamp_ntpfp  assert_tu.ntpfp
 #define clear_timestamp_ntpfp   clear_tu.ntpfp
 
 typedef struct {
+	pps_seq_t	assert_sequence;	/* assert event seq # */
+	pps_seq_t	clear_sequence;		/* clear event seq # */
+	pps_timeu_t	assert_tu;
+	pps_timeu_t	clear_tu;
+	int		current_mode;		/* current mode bits */
+	ffcounter	assert_ffcount;		/* ffcounter on assert event */
+	ffcounter	clear_ffcount;		/* ffcounter on clear event */
+} ffclock_pps_info_t;
+
+typedef struct {
 	int api_version;			/* API version # */
 	int mode;				/* mode bits */
 	pps_timeu_t assert_off_tu;
 	pps_timeu_t clear_off_tu;
 } pps_params_t;
 
 #define assert_offset   assert_off_tu.tspec
 #define clear_offset    clear_off_tu.tspec
 
 #define assert_offset_ntpfp     assert_off_tu.ntpfp
@@ -82,49 +98,60 @@ typedef struct {
 #define PPS_KC_HARDPPS		0
 #define PPS_KC_HARDPPS_PLL	1
 #define PPS_KC_HARDPPS_FLL	2
 
 struct pps_fetch_args {
 	int tsformat;
 	pps_info_t	pps_info_buf;
 	struct timespec	timeout;
 };
 
+struct ffclock_pps_fetch_args {
+	int tsformat;
+	ffclock_pps_info_t	pps_info_buf;
+	struct timespec		timeout;
+};
+
 struct pps_kcbind_args {
 	int kernel_consumer;
 	int edge;
 	int tsformat;
 };
 
 #define PPS_IOC_CREATE		_IO('1', 1)
 #define PPS_IOC_DESTROY		_IO('1', 2)
 #define PPS_IOC_SETPARAMS	_IOW('1', 3, pps_params_t)
 #define PPS_IOC_GETPARAMS	_IOR('1', 4, pps_params_t)
 #define PPS_IOC_GETCAP		_IOR('1', 5, int)
 #define PPS_IOC_FETCH		_IOWR('1', 6, struct pps_fetch_args)
 #define PPS_IOC_KCBIND		_IOW('1', 7, struct pps_kcbind_args)
+#define PPS_IOC_FETCH_FFCLOCK	_IOWR('1', 8, struct ffclock_pps_fetch_args)
 
 #ifdef _KERNEL
 
 struct pps_state {
 	/* Capture information. */
 	struct timehands *capth;
 	unsigned	capgen;
 	unsigned	capcount;
 
 	/* State information. */
 	pps_params_t	ppsparam;
 	pps_info_t	ppsinfo;
 	int		kcmode;
 	int		ppscap;
 	struct timecounter *ppstc;
 	unsigned	ppscount[3];
+#ifdef FFCLOCK
+	ffclock_pps_info_t ffclock_ppsinfo;
+	struct fftimehands *capffth;
+#endif
 };
 
 void pps_capture(struct pps_state *pps);
 void pps_event(struct pps_state *pps, int event);
 void pps_init(struct pps_state *pps);
 int pps_ioctl(unsigned long cmd, caddr_t data, struct pps_state *pps);
 void hardpps(struct timespec *tsp, long nsec);
 
 #else /* !_KERNEL */
 
@@ -177,20 +204,38 @@ time_pps_fetch(pps_handle_t handle, cons
 		arg.timeout.tv_sec = -1;
 		arg.timeout.tv_nsec = -1;
 	} else
 		arg.timeout = *timeout;
 	error = ioctl(handle, PPS_IOC_FETCH, &arg);
 	*ppsinfobuf = arg.pps_info_buf;
 	return (error);
 }
 
 static __inline int
+pps_fetch_ffclock(pps_handle_t handle, const int tsformat,
+	ffclock_pps_info_t *ppsinfobuf, const struct timespec *timeout)
+{
+	int error;
+	struct ffclock_pps_fetch_args arg;
+
+	arg.tsformat = tsformat;
+	if (timeout == NULL) {
+		arg.timeout.tv_sec = -1;
+		arg.timeout.tv_nsec = -1;
+	} else
+		arg.timeout = *timeout;
+	error = ioctl(handle, PPS_IOC_FETCH_FFCLOCK, &arg);
+	*ppsinfobuf = arg.pps_info_buf;
+	return (error);
+}
+
+static __inline int
 time_pps_kcbind(pps_handle_t handle, const int kernel_consumer,
 	const int edge, const int tsformat)
 {
 	struct pps_kcbind_args arg;
 
 	arg.kernel_consumer = kernel_consumer;
 	arg.edge = edge;
 	arg.tsformat = tsformat;
 	return (ioctl(handle, PPS_IOC_KCBIND, &arg));
 }
