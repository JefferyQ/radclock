Feed-forward clock interface.

Provides ffclock kernel module.
Return a feed-forward RAW timestamp to userland.
Allows feed-forward synchronisation daemon to update the kernel feed-forward
clock.

---
 compat/freebsd32/syscalls.master |    8 ++-
 kern/kern_ffclock.c              |   84 +++++++++++++++++++++++++++++++++++++++
 kern/syscalls.master             |    8 ++-
 sys/time.h                       |    1 
 sys/timeffc.h                    |    9 ++++
 5 files changed, 104 insertions(+), 6 deletions(-)

Index: sys/compat/freebsd32/syscalls.master
===================================================================
--- sys.orig/compat/freebsd32/syscalls.master	2011-07-14 10:49:19.000000000 +1000
+++ sys/compat/freebsd32/syscalls.master	2011-07-14 13:49:45.000000000 +1000
@@ -440,23 +440,25 @@
 234	AUE_NULL	STD	{ int freebsd32_clock_getres(clockid_t clock_id, \
 				    struct timespec32 *tp); }
 235	AUE_NULL	UNIMPL	timer_create
 236	AUE_NULL	UNIMPL	timer_delete
 237	AUE_NULL	UNIMPL	timer_settime
 238	AUE_NULL	UNIMPL	timer_gettime
 239	AUE_NULL	UNIMPL	timer_getoverrun
 240	AUE_NULL	STD	{ int freebsd32_nanosleep( \
 				    const struct timespec32 *rqtp, \
 				    struct timespec32 *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	NOPROTO	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	NOPROTO	{ int ffclock_setestimate( \
+				    struct ffclock_estimate *cest); }
+243	AUE_NULL	NOPROTO	{ int ffclock_getestimate( \
+				    struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	UNIMPL	ntp_gettime
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	NOPROTO	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	NOPROTO	{ int rfork(int flags); }
Index: sys/kern/kern_ffclock.c
===================================================================
--- sys.orig/kern/kern_ffclock.c	2011-07-14 13:34:12.000000000 +1000
+++ sys/kern/kern_ffclock.c	2011-07-14 13:46:31.000000000 +1000
@@ -22,26 +22,36 @@
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/module.h>
+#include <sys/mutex.h>
+#include <sys/proc.h>
 #include <sys/sysctl.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
 #include <sys/systm.h>
 #include <sys/timeffc.h>
 
 extern struct ffclock_estimate ffclock_estimate;
 extern struct bintime ffclock_boottime;
+extern int8_t ffclock_updated;
+extern struct mtx ffclock_mtx;
 
 /*
  * Feed-forward clock absolute time. This should be the prefered way to read the
  * feed-forward clock for "wall-clock" type time. The flags allow to compose
  * various flavours of absolute time (e.g. with or without leap seconds taken
  * into account). If valid pointers are provided, the ffcounter value and an
  * upper bound on clock error associated with the bintime are provided.
  * NOTE: use ffclock_convert_abs() to differ the conversion of a ffcounter value
  * read earlier.
  */
@@ -307,10 +317,84 @@ ffclock_nanodifftime(ffcounter ffdelta, 
 }
 
 void
 ffclock_microdifftime(ffcounter ffdelta, struct timeval *tvp)
 {
 	struct bintime bt;
 
 	ffclock_difftime(ffdelta, &bt, NULL);
 	bintime2timeval(&bt, tvp);
 }
+
+/*
+ * System calls returning Feed-Forward Clock counter to user space
+ */
+
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getcounter_args {
+	ffcounter *ffcount;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_getcounter(struct thread *td, struct ffclock_getcounter_args *uap)
+{
+	ffcounter ffcount;
+	int error;
+
+	ffcount = 0;
+	ffclock_read_counter(&ffcount);
+	if (ffcount == 0)
+		return (1);
+	error = copyout(&ffcount, uap->ffcount, sizeof(ffcounter));
+	return (error);
+}
+
+/*
+ * System call allowing the synchronisation daemon to push new feed-foward clock
+ * estimates to the kernel. Acquire ffclock_mtx to prevent several instances of
+ * the daemon to update concurrently and ensure data consistency.
+ * NOTE: ffclock_updated signals the fftimehands that new estimates are
+ * available. The updated estimates are used after up to hz seconds if ticks
+ * are not missed.
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_setestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_setestimate(struct thread *td, struct ffclock_setestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyin(uap->cest, &(ffclock_estimate),
+	    sizeof(struct ffclock_estimate));
+	if (error == 0)
+		ffclock_updated++;
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
+
+/*
+ * System call allowing userland applications to retrieve the clock estimates
+ * stored within the kernel. It is useful to kickstart the synchronisation
+ * daemon, with the kernel's knowledge of hardware timecounter.
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int ffclock_getestimate(struct thread *td, struct ffclock_getestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyout(&(ffclock_estimate), uap->cest,
+	    sizeof(struct ffclock_estimate));
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
Index: sys/kern/syscalls.master
===================================================================
--- sys.orig/kern/syscalls.master	2011-07-14 10:49:19.000000000 +1000
+++ sys/kern/syscalls.master	2011-07-14 13:49:03.000000000 +1000
@@ -449,23 +449,25 @@
 				    struct sigevent *evp, int *timerid); }
 236	AUE_NULL	STD	{ int ktimer_delete(int timerid); }
 237	AUE_NULL	STD	{ int ktimer_settime(int timerid, int flags, \
 				    const struct itimerspec *value, \
 				    struct itimerspec *ovalue); }
 238	AUE_NULL	STD	{ int ktimer_gettime(int timerid, struct \
 				    itimerspec *value); }
 239	AUE_NULL	STD	{ int ktimer_getoverrun(int timerid); }
 240	AUE_NULL	STD	{ int nanosleep(const struct timespec *rqtp, \
 				    struct timespec *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	STD	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	STD	{ int ffclock_setestimate( \
+				    struct ffclock_estimate *cest); }
+243	AUE_NULL	STD	{ int ffclock_getestimate( \
+				    struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	STD	{ int ntp_gettime(struct ntptimeval *ntvp); }
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	STD	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	STD	{ int rfork(int flags); }
Index: sys/sys/time.h
===================================================================
--- sys.orig/sys/time.h	2011-07-14 10:49:19.000000000 +1000
+++ sys/sys/time.h	2011-07-14 13:36:04.000000000 +1000
@@ -26,20 +26,21 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
  *	@(#)time.h	8.5 (Berkeley) 5/4/95
  * $FreeBSD$
  */
 
 #ifndef _SYS_TIME_H_
 #define _SYS_TIME_H_
 
+#include <sys/_ffcounter.h>
 #include <sys/_timeval.h>
 #include <sys/types.h>
 #include <sys/timespec.h>
 
 struct timezone {
 	int	tz_minuteswest;	/* minutes west of Greenwich */
 	int	tz_dsttime;	/* type of dst correction */
 };
 #define	DST_NONE	0	/* not on dst */
 #define	DST_USA		1	/* USA style dst */
Index: sys/sys/timeffc.h
===================================================================
--- sys.orig/sys/timeffc.h	2011-07-14 13:33:01.000000000 +1000
+++ sys/sys/timeffc.h	2011-07-14 13:47:13.000000000 +1000
@@ -151,13 +151,22 @@ void ffclock_getnanouptime(struct timesp
 void ffclock_getmicrouptime(struct timeval *tvp);
 
 /*
  * Wrapper routines to convert a time interval defined by ffcounter values into
  * a time interval in secounds using the current feed-forward clock estimates.
  */
 void ffclock_bindifftime(ffcounter ffdelta, struct bintime *bt);
 void ffclock_nanodifftime(ffcounter ffdelta, struct timespec *tsp);
 void ffclock_microdifftime(ffcounter ffdelta, struct timeval *tvp);
 
+#else /* !_KERNEL */
+
+/* Feed-Forward Clock system calls */
+__BEGIN_DECLS
+int ffclock_getcounter(ffcounter *ffcount);
+int ffclock_getestimate(struct ffclock_estimate *cest);
+int ffclock_setestimate(struct ffclock_estimate *cest);
+__END_DECLS
+
 #endif /* _KERNEL */
 #endif /* __BSD_VISIBLE */
 #endif /* _SYS_TIMEFF_H_ */
