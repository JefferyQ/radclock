Feed-forward clock interface.

Provides ffclock kernel module.
Return a feed-forward RAW timestamp to userland.
Allows feed-forward synchronisation daemon to update the kernel feed-forward
clock.

---
 compat/freebsd32/syscalls.master |    6 +-
 kern/kern_ffclock.c              |   86 +++++++++++++++++++++++++++++++++++++++
 kern/syscalls.master             |    6 +-
 sys/time.h                       |    1 
 sys/timeffc.h                    |    9 ++++
 5 files changed, 102 insertions(+), 6 deletions(-)

Index: sys/compat/freebsd32/syscalls.master
===================================================================
--- sys.orig/compat/freebsd32/syscalls.master	2011-07-14 10:04:36.000000000 +1000
+++ sys/compat/freebsd32/syscalls.master	2011-07-14 10:21:11.000000000 +1000
@@ -440,23 +440,23 @@
 234	AUE_NULL	STD	{ int freebsd32_clock_getres(clockid_t clock_id, \
 				    struct timespec32 *tp); }
 235	AUE_NULL	UNIMPL	timer_create
 236	AUE_NULL	UNIMPL	timer_delete
 237	AUE_NULL	UNIMPL	timer_settime
 238	AUE_NULL	UNIMPL	timer_gettime
 239	AUE_NULL	UNIMPL	timer_getoverrun
 240	AUE_NULL	STD	{ int freebsd32_nanosleep( \
 				    const struct timespec32 *rqtp, \
 				    struct timespec32 *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	NOPROTO	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	NOPROTO	{ int ffclock_setestimate(struct ffclock_estimate *cest); }
+243	AUE_NULL	NOPROTO	{ int ffclock_getestimate(struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	UNIMPL	ntp_gettime
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	NOPROTO	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	NOPROTO	{ int rfork(int flags); }
Index: sys/kern/kern_ffclock.c
===================================================================
--- sys.orig/kern/kern_ffclock.c	2011-07-14 10:19:29.000000000 +1000
+++ sys/kern/kern_ffclock.c	2011-07-14 10:22:00.000000000 +1000
@@ -22,26 +22,36 @@
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #include <sys/cdefs.h>
 #include <sys/param.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/module.h>
+#include <sys/mutex.h>
+#include <sys/proc.h>
 #include <sys/sysctl.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
 #include <sys/systm.h>
 #include <sys/timeffc.h>
 
 extern struct ffclock_estimate ffclock_estimate;
 extern struct bintime ffclock_boottime;
+extern int8_t ffclock_updated;
+extern struct mtx ffclock_mtx;	/* lock against concurrent updates of the ffclock estimates */
 
 /*
  * Feed-forward clock time functions
  */
 void
 ffclock_abstime(ffcounter *ffcount, struct bintime *bt,
     struct bintime *error_bound, uint32_t flags)
 {
 	struct ffclock_estimate cest;
 	ffcounter ffc;
@@ -289,10 +299,86 @@ ffclock_nanodifftime(ffcounter ffdelta, 
 }
 
 void
 ffclock_microdifftime(ffcounter ffdelta, struct timeval *tvp)
 {
 	struct bintime bt;
 
 	ffclock_difftime(ffdelta, &bt, NULL);
 	bintime2timeval(&bt, tvp);
 }
+
+/*
+ * System calls returning Feed-Forward Clock counter to user space
+ */
+
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getcounter_args {
+	ffcounter *ffcount;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_getcounter(struct thread *td, struct ffclock_getcounter_args *uap)
+{
+	ffcounter ffcount;
+	int error;
+
+	ffcount = 0;
+	ffclock_read_counter(&ffcount);
+	if (ffcount == 0)
+		return (1);
+	error = copyout(&ffcount, uap->ffcount, sizeof(ffcounter));
+	return (error);
+}
+
+/*
+ * System call to push feed-foward clock estimates from synchronisation daemon
+ * to the kernel. Hold ffclock_mtx to prevent several instances to update
+ * concurrently, essentially to protect from user's bad practice.
+ * update_ffclock() may bump the generation number without us knowing.
+ *
+ * XXX update comment to reflect what the code does.
+ * mention that updates are acted upon during tc_windup, leading to a delay <= 1/HZ
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_setestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_setestimate(struct thread *td, struct ffclock_setestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyin(uap->cest, &(ffclock_estimate), sizeof(struct ffclock_estimate));
+	if (error == 0)
+		ffclock_updated++;
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
+
+/*
+ * System call for userland applications to retrieve the clock estimates stored
+ * within the kernel. Useful to kickstart the synchronisation daemon, which can
+ * benefit from the kernel's knowledge of hardware timecounter. Also useful if
+ * the synchronisation daemon is not running.
+ * Hold ffclock_mtx to ensure consistency of estimate members possibly updated
+ * by the synchronisation daemon.
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int ffclock_getestimate(struct thread *td, struct ffclock_getestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyout(&(ffclock_estimate), uap->cest, sizeof(struct ffclock_estimate));
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
Index: sys/kern/syscalls.master
===================================================================
--- sys.orig/kern/syscalls.master	2011-07-14 10:04:36.000000000 +1000
+++ sys/kern/syscalls.master	2011-07-14 10:21:11.000000000 +1000
@@ -449,23 +449,23 @@
 				    struct sigevent *evp, int *timerid); }
 236	AUE_NULL	STD	{ int ktimer_delete(int timerid); }
 237	AUE_NULL	STD	{ int ktimer_settime(int timerid, int flags, \
 				    const struct itimerspec *value, \
 				    struct itimerspec *ovalue); }
 238	AUE_NULL	STD	{ int ktimer_gettime(int timerid, struct \
 				    itimerspec *value); }
 239	AUE_NULL	STD	{ int ktimer_getoverrun(int timerid); }
 240	AUE_NULL	STD	{ int nanosleep(const struct timespec *rqtp, \
 				    struct timespec *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	STD	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	STD	{ int ffclock_setestimate(struct ffclock_estimate *cest); }
+243	AUE_NULL	STD	{ int ffclock_getestimate(struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	STD	{ int ntp_gettime(struct ntptimeval *ntvp); }
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	STD	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	STD	{ int rfork(int flags); }
Index: sys/sys/time.h
===================================================================
--- sys.orig/sys/time.h	2011-07-14 10:04:36.000000000 +1000
+++ sys/sys/time.h	2011-07-14 10:21:11.000000000 +1000
@@ -26,20 +26,21 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
  *	@(#)time.h	8.5 (Berkeley) 5/4/95
  * $FreeBSD$
  */
 
 #ifndef _SYS_TIME_H_
 #define _SYS_TIME_H_
 
+#include <sys/_ffcounter.h>
 #include <sys/_timeval.h>
 #include <sys/types.h>
 #include <sys/timespec.h>
 
 struct timezone {
 	int	tz_minuteswest;	/* minutes west of Greenwich */
 	int	tz_dsttime;	/* type of dst correction */
 };
 #define	DST_NONE	0	/* not on dst */
 #define	DST_USA		1	/* USA style dst */
Index: sys/sys/timeffc.h
===================================================================
--- sys.orig/sys/timeffc.h	2011-07-14 10:20:32.000000000 +1000
+++ sys/sys/timeffc.h	2011-07-14 10:21:11.000000000 +1000
@@ -146,13 +146,22 @@ void ffclock_nanouptime(struct timespec 
 void ffclock_microuptime(struct timeval *tvp);
 
 void ffclock_getbinuptime(struct bintime *bt);
 void ffclock_getnanouptime(struct timespec *tsp);
 void ffclock_getmicrouptime(struct timeval *tvp);
 
 void ffclock_bindifftime(ffcounter ffdelta, struct bintime *bt);
 void ffclock_nanodifftime(ffcounter ffdelta, struct timespec *tsp);
 void ffclock_microdifftime(ffcounter ffdelta, struct timeval *tvp);
 
+#else /* !_KERNEL */
+
+/* Feed-Forward Clock system calls */
+__BEGIN_DECLS
+int ffclock_getcounter(ffcounter *ffcount);
+int ffclock_getestimate(struct ffclock_estimate *cest);
+int ffclock_setestimate(struct ffclock_estimate *cest);
+__END_DECLS
+
 #endif /* _KERNEL */
 #endif /* __BSD_VISIBLE */
 #endif /* _SYS_TIMEFF_H_ */
