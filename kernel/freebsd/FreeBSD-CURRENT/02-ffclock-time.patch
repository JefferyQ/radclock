---
 conf/files          |    1 
 kern/kern_ffclock.c |  254 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 sys/timeffc.h       |   40 ++++++++
 3 files changed, 295 insertions(+)

Index: sys/kern/kern_ffclock.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sys/kern/kern_ffclock.c	2011-06-25 21:45:41.000000000 +1000
@@ -0,0 +1,254 @@
+/*-
+ * Copyright (C) 2010 University of Melbourne
+ * All rights reserved.
+ *
+ * This software was developed by the University of Melbourne under sponsorship
+ * from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/timeffc.h>
+
+
+extern struct ffclock_estimate ffclock_estimate;
+extern struct bintime ffclock_boottimebin;
+
+/*
+ * Feed-Forward Clock time functions
+ */
+void
+ffclock_abstime(ffcounter *ffcount, struct bintime *bt,
+				struct bintime *error_bound, unsigned char flags)
+{
+	struct ffclock_estimate cest;
+	ffcounter update_ffcount;
+	ffcounter ffdelta_error;
+
+// TODO: Check options, bit mask
+	if ((flags & FFCLOCK_FAST) == FFCLOCK_FAST)
+		ffclock_abstime_tc(ffcount, bt);
+	else
+		ffclock_abstime_tc_coarse(ffcount, bt);
+
+	/* Current ffclock estimate, use update_ffcount as generation number */
+	do {
+		update_ffcount = ffclock_estimate.update_ffcount;
+		bcopy(&ffclock_estimate, &cest, sizeof(struct ffclock_estimate));
+	} while (update_ffcount != ffclock_estimate.update_ffcount);
+
+	/*
+	 * Leap second adjustement. Total as seen by synchronisation algorithm since
+	 * it started. cest.leapsec_next is the ffcounter prediction of when the next
+	 * leapsecond occurs.
+	 */
+	if ((flags & FFCLOCK_LEAPSEC) == FFCLOCK_LEAPSEC) {
+		bt->sec -= cest.leapsec_total;
+		if (*ffcount > cest.leapsec_next)
+			bt->sec -= cest.leapsec;
+	}
+
+	if (error_bound) {
+		ffdelta_error = *ffcount - cest.update_ffcount;
+		ffclock_difftime_tc(&ffdelta_error, error_bound);
+		/* 18446744073709 = int(2^64 / 1e12), err_bound_rate in [ps/s] */
+		bintime_mul(error_bound, cest.error_bound_rate * (uint64_t)18446744073709LL);
+		/* 18446744073 = int(2^64 / 1e9), since err_abs in [ns] */
+		bintime_addx(error_bound, cest.error_bound_abs * (uint64_t)18446744073LL);
+	}
+}
+
+void
+ffclock_difftime(ffcounter *ffdelta, struct bintime *bt,
+				struct bintime *error_bound, unsigned char flags)
+{
+	ffcounter update_ffcount;
+	uint32_t err_rate;
+
+// TODO: Check options, bit mask
+	ffclock_difftime_tc(ffdelta, bt);
+
+	if (error_bound) {
+		do {
+			update_ffcount = ffclock_estimate.update_ffcount;
+			err_rate = ffclock_estimate.error_bound_rate;
+		} while (update_ffcount != ffclock_estimate.update_ffcount);
+
+		ffclock_difftime_tc(ffdelta, error_bound);
+		/* 18446744073709 = int(2^64 / 1e12), err_bound_rate in [ps/s] */
+		bintime_mul(error_bound, err_rate * (uint64_t)18446744073709LL);
+	}
+}
+
+
+/*
+ * High level functions to access the Feed-Forward Clock.
+ */
+void
+ffclock_bintime(struct bintime *bt)
+{
+	ffcounter ffcount;
+
+	ffcount = read_ffcounter();
+	ffclock_abstime(&ffcount, bt, NULL, FFCLOCK_MONOTONIC | FFCLOCK_LEAPSEC);
+}
+
+void
+ffclock_nanotime(struct timespec *tsp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffcount = read_ffcounter();
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_MONOTONIC | FFCLOCK_LEAPSEC);
+	bintime2timespec(&bt, tsp);
+}
+
+void
+ffclock_microtime(struct timeval *tvp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffcount = read_ffcounter();
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_MONOTONIC | FFCLOCK_LEAPSEC);
+	bintime2timeval(&bt, tvp);
+}
+
+void
+ffclock_getbintime(struct bintime *bt)
+{
+	ffcounter ffcount;
+
+	ffclock_abstime(&ffcount, bt, NULL, FFCLOCK_FAST | FFCLOCK_LEAPSEC);
+}
+
+void
+ffclock_getnanotime(struct timespec *tsp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_FAST | FFCLOCK_LEAPSEC);
+	bintime2timespec(&bt, tsp);
+}
+
+void
+ffclock_getmicrotime(struct timeval *tvp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_FAST | FFCLOCK_LEAPSEC);
+	bintime2timeval(&bt, tvp);
+}
+
+void
+ffclock_binuptime(struct bintime *bt)
+{
+	ffcounter ffcount;
+
+	ffcount = read_ffcounter();
+	ffclock_abstime(&ffcount, bt, NULL, FFCLOCK_MONOTONIC | FFCLOCK_LEAPSEC);
+	bintime_sub(bt, &ffclock_boottimebin);
+}
+
+void
+ffclock_nanouptime(struct timespec *tsp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffcount = read_ffcounter();
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_MONOTONIC | FFCLOCK_LEAPSEC);
+	bintime_sub(bt, &ffclock_boottimebin);
+	bintime2timespec(&bt, tsp);
+}
+
+void
+ffclock_microuptime(struct timeval *tvp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffcount = read_ffcounter();
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_MONOTONIC | FFCLOCK_LEAPSEC);
+	bintime_sub(bt, &ffclock_boottimebin);
+	bintime2timeval(&bt, tvp);
+}
+
+void
+ffclock_getbinuptime(struct bintime *bt)
+{
+	ffcounter ffcount;
+
+	ffclock_abstime(&ffcount, bt, NULL, FFCLOCK_FAST | FFCLOCK_LEAPSEC);
+	bintime_sub(bt, &ffclock_boottimebin);
+}
+
+void
+ffclock_getnanouptime(struct timespec *tsp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_FAST | FFCLOCK_LEAPSEC);
+	bintime_sub(bt, &ffclock_boottimebin);
+	bintime2timespec(&bt, tsp);
+}
+
+void
+ffclock_getmicrouptime(struct timeval *tvp)
+{
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffclock_abstime(&ffcount, &bt, NULL, FFCLOCK_FAST | FFCLOCK_LEAPSEC);
+	bintime_sub(bt, &ffclock_boottimebin);
+	bintime2timeval(&bt, tvp);
+}
+
+void
+ffclock_bindifftime(ffcounter *ffdelta, struct bintime *bt)
+{
+
+	ffclock_difftime(ffdelta, bt, NULL, 0);
+}
+
+void
+ffclock_nanodifftime(ffcounter *ffdelta, struct timespec *tsp)
+{
+	struct bintime bt;
+
+	ffclock_difftime(ffdelta, &bt, NULL, 0);
+	bintime2timespec(&bt, tsp);
+}
+
+void
+ffclock_microdifftime(ffcounter *ffdelta, struct timeval *tvp)
+{
+	struct bintime bt;
+
+	ffclock_difftime(ffdelta, &bt, NULL, 0);
+	bintime2timeval(&bt, tvp);
+}
+
Index: sys/conf/files
===================================================================
--- sys.orig/conf/files	2011-06-24 17:36:47.000000000 +1000
+++ sys/conf/files	2011-06-24 18:19:05.000000000 +1000
@@ -2293,20 +2293,21 @@ kern/kern_cpu.c			standard
 kern/kern_cpuset.c		standard
 kern/kern_context.c		standard
 kern/kern_descrip.c		standard
 kern/kern_dtrace.c		optional kdtrace_hooks
 kern/kern_environment.c		standard
 kern/kern_et.c			standard
 kern/kern_event.c		standard
 kern/kern_exec.c		standard
 kern/kern_exit.c		standard
 kern/kern_fail.c		standard
+kern/kern_ffclock.c		optional ffclock
 kern/kern_fork.c		standard
 kern/kern_gzio.c		optional gzio
 kern/kern_hhook.c		standard
 kern/kern_idle.c		standard
 kern/kern_intr.c		standard
 kern/kern_jail.c		standard
 kern/kern_khelp.c		standard
 kern/kern_kthread.c		standard
 kern/kern_ktr.c			optional ktr
 kern/kern_ktrace.c		standard
Index: sys/sys/timeffc.h
===================================================================
--- sys.orig/sys/timeffc.h	2011-06-24 17:36:47.000000000 +1000
+++ sys/sys/timeffc.h	2011-06-24 18:19:05.000000000 +1000
@@ -65,13 +65,53 @@ struct ffclock_estimate {
  * the error of the absolute time or time interval returned.
  */
 ffcounter read_ffcounter(void);
 void ffclock_difftime_tc(ffcounter *ffdelta, struct bintime *bt);
 void ffclock_abstime_tc(ffcounter *ffcount, struct bintime *bt);
 void ffclock_abstime_tc_coarse(ffcounter *ffcount, struct bintime *bt);
 
 /* Resets the feed-forward clock */
 void ffclock_reset_clock(struct timespec *ts);
 
+/*
+ * Clock options that define how the Feed-Forward counter is converted to
+ * absolute time
+ */
+#define FFCLOCK_MONOTONIC	1
+#define FFCLOCK_LEAPSEC		2
+#define FFCLOCK_FAST		4
+
+void ffclock_abstime(ffcounter *ffcount, struct bintime *bt, struct bintime *error_bound, unsigned char flags);
+void ffclock_difftime(ffcounter *ffcount, struct bintime *bt, struct bintime *error_bound, unsigned char flags);
+
+/*
+ * These are high level function to compute absolute time and time intervals
+ * using the Feed-Forward Clock. These functions are loosely named after those
+ * defined in <sys/time.h>, see there for a description of the original ones.
+ * This set of functions is different from the ones defined in <sys/time.h>
+ * since not all them make sense in a Feed-Forward paradigm.
+ * These do not retur error bounds associated with absolute time or time
+ * intervals.
+ */
+void ffclock_bintime(struct bintime *bt);
+void ffclock_nanotime(struct timespec *tsp);
+void ffclock_microtime(struct timeval *tvp);
+
+void ffclock_getbintime(struct bintime *bt);
+void ffclock_getnanotime(struct timespec *tsp);
+void ffclock_getmicrotime(struct timeval *tvp);
+
+void ffclock_binuptime(struct bintime *bt);
+void ffclock_nanouptime(struct timespec *tsp);
+void ffclock_microuptime(struct timeval *tvp);
+
+void ffclock_getbinuptime(struct bintime *bt);
+void ffclock_getnanouptime(struct timespec *tsp);
+void ffclock_getmicrouptime(struct timeval *tvp);
+
+void ffclock_bindifftime(ffcounter *ffdelta, struct bintime *bt);
+void ffclock_nanodifftime(ffcounter *ffdelta, struct timespec *tsp);
+void ffclock_microdifftime(ffcounter *ffdelta, struct timeval *tvp);
+
 #endif /* _KERNEL */
 #endif /* __BSD_VISIBLE */
 #endif /* _SYS_TIMEFF_H */
