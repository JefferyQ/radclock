Feed-forward clock interface.

Provides ffclock kernel module.
Return a feed-forward RAW timestamp to userland.
Allows feed-forward synchronisation daemon to update the kernel feed-forward
clock.

---
 compat/freebsd32/syscalls.master |    6 +-
 conf/files                       |    1 
 kern/kern_ffclock.c              |  100 +++++++++++++++++++++++++++++++++++++++
 kern/syscalls.master             |    6 +-
 sys/time.h                       |    1 
 sys/timeffc.h                    |    8 +++
 6 files changed, 116 insertions(+), 6 deletions(-)

Index: sys/kern/syscalls.master
===================================================================
--- sys.orig/kern/syscalls.master	2011-06-22 18:18:34.000000000 +1000
+++ sys/kern/syscalls.master	2011-06-22 18:22:07.000000000 +1000
@@ -449,23 +449,23 @@
 				    struct sigevent *evp, int *timerid); }
 236	AUE_NULL	STD	{ int ktimer_delete(int timerid); }
 237	AUE_NULL	STD	{ int ktimer_settime(int timerid, int flags, \
 				    const struct itimerspec *value, \
 				    struct itimerspec *ovalue); }
 238	AUE_NULL	STD	{ int ktimer_gettime(int timerid, struct \
 				    itimerspec *value); }
 239	AUE_NULL	STD	{ int ktimer_getoverrun(int timerid); }
 240	AUE_NULL	STD	{ int nanosleep(const struct timespec *rqtp, \
 				    struct timespec *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	STD	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	STD	{ int ffclock_setestimate(struct ffclock_estimate *cest); }
+243	AUE_NULL	STD	{ int ffclock_getestimate(struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	STD	{ int ntp_gettime(struct ntptimeval *ntvp); }
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	STD	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	STD	{ int rfork(int flags); }
Index: sys/sys/time.h
===================================================================
--- sys.orig/sys/time.h	2011-06-22 18:18:34.000000000 +1000
+++ sys/sys/time.h	2011-06-22 18:22:07.000000000 +1000
@@ -26,20 +26,21 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
  *	@(#)time.h	8.5 (Berkeley) 5/4/95
  * $FreeBSD$
  */
 
 #ifndef _SYS_TIME_H_
 #define _SYS_TIME_H_
 
+#include <sys/_ffcounter.h>
 #include <sys/_timeval.h>
 #include <sys/types.h>
 #include <sys/timespec.h>
 
 struct timezone {
 	int	tz_minuteswest;	/* minutes west of Greenwich */
 	int	tz_dsttime;	/* type of dst correction */
 };
 #define	DST_NONE	0	/* not on dst */
 #define	DST_USA		1	/* USA style dst */
Index: sys/sys/timeffc.h
===================================================================
--- sys.orig/sys/timeffc.h	2011-06-22 18:18:34.000000000 +1000
+++ sys/sys/timeffc.h	2011-06-22 18:22:07.000000000 +1000
@@ -46,20 +46,28 @@ struct ffclock_estimate {
 	uint64_t	period;				/* Long-term estimate of counter period */
 	uint64_t	period_shortterm;	/* Short-term estimate of counter period */
 	uint32_t	error_bound_abs;	/* Bound on absolute clock error [ns] */
 	uint32_t	error_bound_rate;	/* Bound on counter rate error [ps/s] */
 	uint32_t	status;				/* Clock status */
 	int16_t		leapsec_total;		/* All leap seconds seen so far */
 	int8_t		leapsec;			/* Next leap second, usually in {-1,0,1} */
 };
 
 #if __BSD_VISIBLE
+
+/* Feed-Forward Clock system calls */
+__BEGIN_DECLS
+int ffclock_getcounter(ffcounter *ffcount);
+int ffclock_getestimate(struct ffclock_estimate *cest);
+int ffclock_setestimate(struct ffclock_estimate *cest);
+__END_DECLS
+
 #ifdef _KERNEL
 
 /* Resets the feed-forward clock */
 void ffclock_reset_clock(struct timespec *ts);
 
 /* Read the current value of the feed-forward counter */
 ffcounter read_ffcounter(void);
 
 /*
  * These are low level functions to compute absolute time and time intervals
Index: sys/compat/freebsd32/syscalls.master
===================================================================
--- sys.orig/compat/freebsd32/syscalls.master	2011-06-22 18:18:34.000000000 +1000
+++ sys/compat/freebsd32/syscalls.master	2011-06-22 18:22:07.000000000 +1000
@@ -440,23 +440,23 @@
 234	AUE_NULL	STD	{ int freebsd32_clock_getres(clockid_t clock_id, \
 				    struct timespec32 *tp); }
 235	AUE_NULL	UNIMPL	timer_create
 236	AUE_NULL	UNIMPL	timer_delete
 237	AUE_NULL	UNIMPL	timer_settime
 238	AUE_NULL	UNIMPL	timer_gettime
 239	AUE_NULL	UNIMPL	timer_getoverrun
 240	AUE_NULL	STD	{ int freebsd32_nanosleep( \
 				    const struct timespec32 *rqtp, \
 				    struct timespec32 *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	NOPROTO	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	NOPROTO	{ int ffclock_setestimate(struct ffclock_estimate *cest); }
+243	AUE_NULL	NOPROTO	{ int ffclock_getestimate(struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	UNIMPL	ntp_gettime
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	NOPROTO	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	NOPROTO	{ int rfork(int flags); }
Index: sys/kern/kern_ffclock.c
===================================================================
--- sys.orig/kern/kern_ffclock.c	2011-06-22 18:21:59.000000000 +1000
+++ sys/kern/kern_ffclock.c	2011-06-22 18:24:36.000000000 +1000
@@ -20,20 +20,32 @@
  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
+#include <sys/param.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/module.h>
+#include <sys/proc.h>
+#include <sys/sysproto.h>  // TODO: check this is the right way of doing things
+#include <sys/sysctl.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
+#include <sys/systm.h>
 #include <sys/timeffc.h>
 
 /*
  * High level functions to access the Feed-Forward Clock.
  */
 void ffclock_bintime(struct bintime *bt)
 {
 	ffcounter ffcount;
 
 	ffcount = read_ffcounter();
@@ -60,10 +72,98 @@ void ffclock_microtime(struct timeval *t
 	bintime2timespec(&bt, tvp);
 }
 
 void ffclock_getbintime(struct bintime *bt)
 void ffclock_getnanotime(struct timespec *tsp)
 void ffclock_getmicrotime(struct timeval *tvp)
 
 void ffclock_bindifftime(struct bintime *bt)
 void ffclock_nanodifftime(struct timespec *tsp);
 void ffclock_microdifftime(struct timeval *tvp);
+
+/*
+ * Sysctl for the Feed-Forward Clock
+ */
+
+static int ffclock_version = 2;
+SYSCTL_NODE(_kern, OID_AUTO, ffclock, CTLFLAG_RW, 0, "Feed-Forward Clock Support");
+SYSCTL_INT(_kern_ffclock, OID_AUTO, version, CTLFLAG_RD, &ffclock_version, 0, "Version of Feed-Forward Clock Support");
+
+/*
+ * System calls returning Feed-Forward Clock counter to user space
+ */
+
+extern struct ffclock_estimate ffclock_estimate;
+extern uint8_t ffclock_fetch_update;
+extern struct mtx ffclock_mtx;	/* lock against concurrent updates of the ffclock estimates */
+
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getcounter_args {
+	ffcounter *ffcount;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_getcounter(struct thread *td, struct ffclock_getcounter_args *uap)
+{
+	ffcounter ffcount;
+	int error;
+
+	ffcount = 0;
+	ffcount = read_ffcounter();
+	if (ffcount == 0)
+		return (1);
+	error = copyout(&ffcount, uap->ffcount, sizeof(ffcounter));
+	return (error);
+}
+
+/*
+ * System call to push feed-foward clock estimates from synchronisation daemon
+ * to the kernel. Hold ffclock_mtx to prevent several instances to update
+ * concurrently, essentially to protect from user's bad practice.
+ * update_ffclock() may bump the generation number without us knowing.
+ *
+ * XXX update comment to reflect what the code does.
+ * mention that updates are acted upon during tc_windup, leading to a delay <= 1/HZ
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_setestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_setestimate(struct thread *td, struct ffclock_setestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyin(uap->cest, &(ffclock_estimate), sizeof(struct ffclock_estimate));
+	if (error == 0)
+		ffclock_fetch_update = 1;
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
+
+/*
+ * System call for userland applications to retrieve the clock estimates stored
+ * within the kernel. Useful to kickstart the synchronisation daemon, which can
+ * benefit from the kernel's knowledge of hardware timecounter. Also useful if
+ * the synchronisation daemon is not running.
+ * Hold ffclock_mtx to ensure consistency of estimate members possibly updated
+ * by the synchronisation daemon.
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int ffclock_getestimate(struct thread *td, struct ffclock_getestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyout(&(ffclock_estimate), uap->cest, sizeof(struct ffclock_estimate));
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
