Feed-forward clock interface.

Provides ffclock kernel module.
Return a feed-forward RAW timestamp to userland.
Allows feed-forward synchronisation daemon to update the kernel feed-forward
clock.

---
 compat/freebsd32/syscalls.master |    6 -
 kern/kern_ffclock.c              |  128 +++++++++++++++++++++++++++++++++++----
 kern/syscalls.master             |    6 -
 sys/time.h                       |    1 
 sys/timeffc.h                    |    8 ++
 5 files changed, 132 insertions(+), 17 deletions(-)

Index: sys/kern/syscalls.master
===================================================================
--- sys.orig/kern/syscalls.master	2011-06-23 22:37:08.000000000 +1000
+++ sys/kern/syscalls.master	2011-06-23 22:44:57.000000000 +1000
@@ -449,23 +449,23 @@
 				    struct sigevent *evp, int *timerid); }
 236	AUE_NULL	STD	{ int ktimer_delete(int timerid); }
 237	AUE_NULL	STD	{ int ktimer_settime(int timerid, int flags, \
 				    const struct itimerspec *value, \
 				    struct itimerspec *ovalue); }
 238	AUE_NULL	STD	{ int ktimer_gettime(int timerid, struct \
 				    itimerspec *value); }
 239	AUE_NULL	STD	{ int ktimer_getoverrun(int timerid); }
 240	AUE_NULL	STD	{ int nanosleep(const struct timespec *rqtp, \
 				    struct timespec *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	STD	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	STD	{ int ffclock_setestimate(struct ffclock_estimate *cest); }
+243	AUE_NULL	STD	{ int ffclock_getestimate(struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	STD	{ int ntp_gettime(struct ntptimeval *ntvp); }
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	STD	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	STD	{ int rfork(int flags); }
Index: sys/sys/time.h
===================================================================
--- sys.orig/sys/time.h	2011-06-23 22:37:08.000000000 +1000
+++ sys/sys/time.h	2011-06-23 22:44:57.000000000 +1000
@@ -26,20 +26,21 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
  *	@(#)time.h	8.5 (Berkeley) 5/4/95
  * $FreeBSD$
  */
 
 #ifndef _SYS_TIME_H_
 #define _SYS_TIME_H_
 
+#include <sys/_ffcounter.h>
 #include <sys/_timeval.h>
 #include <sys/types.h>
 #include <sys/timespec.h>
 
 struct timezone {
 	int	tz_minuteswest;	/* minutes west of Greenwich */
 	int	tz_dsttime;	/* type of dst correction */
 };
 #define	DST_NONE	0	/* not on dst */
 #define	DST_USA		1	/* USA style dst */
Index: sys/sys/timeffc.h
===================================================================
--- sys.orig/sys/timeffc.h	2011-06-23 22:37:31.000000000 +1000
+++ sys/sys/timeffc.h	2011-06-23 22:44:57.000000000 +1000
@@ -97,12 +97,20 @@ void ffclock_microtime(struct timeval *t
 
 void ffclock_getbintime(struct bintime *bt);
 void ffclock_getnanotime(struct timespec *tsp);
 void ffclock_getmicrotime(struct timeval *tvp);
 
 void ffclock_bindifftime(ffcounter *ffdelta, struct bintime *bt);
 void ffclock_nanodifftime(ffcounter *ffdelta, struct timespec *tsp);
 void ffclock_microdifftime(ffcounter *ffdelta, struct timeval *tvp);
 
 #endif /* _KERNEL */
+
+/* Feed-Forward Clock system calls */
+__BEGIN_DECLS
+int ffclock_getcounter(ffcounter *ffcount);
+int ffclock_getestimate(struct ffclock_estimate *cest);
+int ffclock_setestimate(struct ffclock_estimate *cest);
+__END_DECLS
+
 #endif /* __BSD_VISIBLE */
 #endif /* _SYS_TIMEFF_H */
Index: sys/compat/freebsd32/syscalls.master
===================================================================
--- sys.orig/compat/freebsd32/syscalls.master	2011-06-23 22:37:08.000000000 +1000
+++ sys/compat/freebsd32/syscalls.master	2011-06-23 22:44:57.000000000 +1000
@@ -440,23 +440,23 @@
 234	AUE_NULL	STD	{ int freebsd32_clock_getres(clockid_t clock_id, \
 				    struct timespec32 *tp); }
 235	AUE_NULL	UNIMPL	timer_create
 236	AUE_NULL	UNIMPL	timer_delete
 237	AUE_NULL	UNIMPL	timer_settime
 238	AUE_NULL	UNIMPL	timer_gettime
 239	AUE_NULL	UNIMPL	timer_getoverrun
 240	AUE_NULL	STD	{ int freebsd32_nanosleep( \
 				    const struct timespec32 *rqtp, \
 				    struct timespec32 *rmtp); }
-241	AUE_NULL	UNIMPL	nosys
-242	AUE_NULL	UNIMPL	nosys
-243	AUE_NULL	UNIMPL	nosys
+241	AUE_NULL	NOPROTO	{ int ffclock_getcounter(ffcounter *ffcount); }
+242	AUE_NULL	NOPROTO	{ int ffclock_setestimate(struct ffclock_estimate *cest); }
+243	AUE_NULL	NOPROTO	{ int ffclock_getestimate(struct ffclock_estimate *cest); }
 244	AUE_NULL	UNIMPL	nosys
 245	AUE_NULL	UNIMPL	nosys
 246	AUE_NULL	UNIMPL	nosys
 247	AUE_NULL	UNIMPL	nosys
 248	AUE_NULL	UNIMPL	ntp_gettime
 249	AUE_NULL	UNIMPL	nosys
 ; syscall numbers initially used in OpenBSD
 250	AUE_MINHERIT	NOPROTO	{ int minherit(void *addr, size_t len, \
 				    int inherit); }
 251	AUE_RFORK	NOPROTO	{ int rfork(int flags); }
Index: sys/kern/kern_ffclock.c
===================================================================
--- sys.orig/kern/kern_ffclock.c	2011-06-23 22:42:50.000000000 +1000
+++ sys/kern/kern_ffclock.c	2011-06-23 22:50:45.000000000 +1000
@@ -20,24 +20,38 @@
  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
+#include <sys/param.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/module.h>
+#include <sys/proc.h>
+#include <sys/sysproto.h>  // TODO: check this is the right way of doing things
+#include <sys/sysctl.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
+#include <sys/systm.h>
 #include <sys/timeffc.h>
 
 
 extern struct ffclock_estimate ffclock_estimate;
+extern uint8_t ffclock_fetch_update;
+extern struct mtx ffclock_mtx;	/* lock against concurrent updates of the ffclock estimates */
 
 /*
  * Feed-Forward Clock time functions
  */
 void
 ffclock_abstime(ffcounter *ffcount, struct bintime *bt,
 				struct bintime *error_bound, unsigned char flags)
 {
 	struct ffclock_estimate cest;
 	ffcounter last_update;
@@ -100,73 +114,165 @@ ffclock_difftime(ffcounter *ffdelta, str
 
 
 /*
  * High level functions to access the Feed-Forward Clock.
  */
 void ffclock_bintime(struct bintime *bt)
 {
 	ffcounter ffcount;
 
 	ffcount = read_ffcounter();
-	ffclock_abstime(&ffcount, bt, NULL);
+	ffclock_abstime(&ffcount, bt, NULL, 0);
 }
 
 void ffclock_nanotime(struct timespec *tsp)
 {
 	struct bintime bt;
 	ffcounter ffcount;
 
 	ffcount = read_ffcounter();
-	ffclock_abstime(&ffcount, &bt, NULL);
+	ffclock_abstime(&ffcount, &bt, NULL, 0);
 	bintime2timespec(&bt, tsp);
 }
 
 void ffclock_microtime(struct timeval *tvp)
 {
 	struct bintime bt;
 	ffcounter ffcount;
 
 	ffcount = read_ffcounter();
-	ffclock_abstime(&ffcount, &bt, NULL);
+	ffclock_abstime(&ffcount, &bt, NULL, 0);
 	bintime2timeval(&bt, tvp);
 }
 
 void ffclock_getbintime(struct bintime *bt)
 {
+	ffcounter ffcount;
 
-	ffclock_abstime_coarse(bt);
+	ffclock_abstime_tc_coarse(&ffcount, bt, NULL, FFCLOCK_FAST);
 }
 
 void ffclock_getnanotime(struct timespec *tsp)
 {
-	ffclock_abstime_coarse(&bt);
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffclock_abstime_tc_coarse(&ffcount, &bt, NULL, FFCLOCK_FAST);
 	bintime2timespec(&bt, tsp);
 }
 
 void ffclock_getmicrotime(struct timeval *tvp)
 {
-	ffclock_abstime_coarse(&bt);
+	struct bintime bt;
+	ffcounter ffcount;
+
+	ffclock_abstime_tc_coarse(&ffcount, &bt, NULL, FFCLOCK_FAST);
 	bintime2timeval(&bt, tvp);
 }
 
 void ffclock_bindifftime(ffcounter *ffdelta, struct bintime *bt)
 {
 
-	ffclock_difftime(ffdelta, bt, NULL);
+	ffclock_difftime(ffdelta, bt, NULL, 0);
 }
 
-void ffclock_nanodifftime(ffcounter *ffdelta, struct timespec *tsp);
+void ffclock_nanodifftime(ffcounter *ffdelta, struct timespec *tsp)
 {
 	struct bintime bt;
 
-	ffclock_difftime(ffdelta, &bt, NULL);
+	ffclock_difftime(ffdelta, &bt, NULL, 0);
 	bintime2timespec(&bt, tsp);
 }
 
-void ffclock_microdifftime(ffcounter *ffdelta, struct timeval *tvp);
+void ffclock_microdifftime(ffcounter *ffdelta, struct timeval *tvp)
 {
 	struct bintime bt;
 
-	ffclock_difftime(ffdelta, &bt, NULL);
+	ffclock_difftime(ffdelta, &bt, NULL, 0);
 	bintime2timeval(&bt, tvp);
 }
 
+/*
+ * Sysctl for the Feed-Forward Clock
+ */
+
+static int ffclock_version = 2;
+SYSCTL_NODE(_kern, OID_AUTO, ffclock, CTLFLAG_RW, 0, "Feed-Forward Clock Support");
+SYSCTL_INT(_kern_ffclock, OID_AUTO, version, CTLFLAG_RD, &ffclock_version, 0, "Version of Feed-Forward Clock Support");
+
+/*
+ * System calls returning Feed-Forward Clock counter to user space
+ */
+
+
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getcounter_args {
+	ffcounter *ffcount;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_getcounter(struct thread *td, struct ffclock_getcounter_args *uap)
+{
+	ffcounter ffcount;
+	int error;
+
+	ffcount = 0;
+	ffcount = read_ffcounter();
+	if (ffcount == 0)
+		return (1);
+	error = copyout(&ffcount, uap->ffcount, sizeof(ffcounter));
+	return (error);
+}
+
+/*
+ * System call to push feed-foward clock estimates from synchronisation daemon
+ * to the kernel. Hold ffclock_mtx to prevent several instances to update
+ * concurrently, essentially to protect from user's bad practice.
+ * update_ffclock() may bump the generation number without us knowing.
+ *
+ * XXX update comment to reflect what the code does.
+ * mention that updates are acted upon during tc_windup, leading to a delay <= 1/HZ
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_setestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int
+ffclock_setestimate(struct thread *td, struct ffclock_setestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyin(uap->cest, &(ffclock_estimate), sizeof(struct ffclock_estimate));
+	if (error == 0)
+		ffclock_fetch_update = 1;
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
+
+/*
+ * System call for userland applications to retrieve the clock estimates stored
+ * within the kernel. Useful to kickstart the synchronisation daemon, which can
+ * benefit from the kernel's knowledge of hardware timecounter. Also useful if
+ * the synchronisation daemon is not running.
+ * Hold ffclock_mtx to ensure consistency of estimate members possibly updated
+ * by the synchronisation daemon.
+ */
+#ifndef _SYS_SYSPROTO_H_
+struct ffclock_getestimate_args {
+	struct ffclock_estimate *cest;
+};
+#endif
+/* ARGSUSED */
+int ffclock_getestimate(struct thread *td, struct ffclock_getestimate_args *uap)
+{
+	int error;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyout(&(ffclock_estimate), uap->cest, sizeof(struct ffclock_estimate));
+	mtx_unlock(&ffclock_mtx);
+	return (error);
+}
+
