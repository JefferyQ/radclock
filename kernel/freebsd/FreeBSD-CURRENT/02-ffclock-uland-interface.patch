Feed-forward clock interface.

Provides ffclock kernel module.
Return a feed-forward RAW timestamp to userland.
Allows feed-forward synchronisation daemon to update the kernel feed-forward
clock.

---
 kern/ffclock.c           |  250 +++++++++++++++++++++++++++++++++++++++++++++++
 modules/Makefile         |    1 
 modules/ffclock/Makefile |   16 +++
 3 files changed, 267 insertions(+)

Index: sys/kern/ffclock.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sys/kern/ffclock.c	2011-03-30 16:06:11.000000000 +1100
@@ -0,0 +1,240 @@
+/*-
+ * Copyright (C) 2010 University of Melbourne
+ * All rights reserved.
+ *
+ * This software was developed by the University of Melbourne under sponsorship
+ * from the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * System calls to access the cumulative virtual timecounter
+ */
+
+#include <sys/param.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/module.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+#include <sys/sysent.h>
+#include <sys/sysproto.h>
+#include <sys/systm.h>
+#include <sys/timeff.h>
+
+extern struct ffclock_estimate ffclock;
+extern uint8_t ffclock_fetch_update;
+
+static struct mtx ffclock_mtx;	/* lock against concurrent updates of the ffclock estimates */
+
+/*
+ * Sysctl
+ */
+static int ffclock_version = 2;
+SYSCTL_NODE(_kern, OID_AUTO, ffclock, CTLFLAG_RW, 0, "Feed-Forward Clock Support");
+SYSCTL_INT(_kern_ffclock, OID_AUTO, version, CTLFLAG_RD, &ffclock_version, 0, "Version of Feed-Forward Clock Support");
+
+/*
+ * First system call is get_ffcounter to retrieve the current value
+ * of the cumulative vritual counter from the timecounter interface
+ */
+struct get_ffcounter_args {
+	ffcounter *ffcount;
+};
+
+static int
+get_ffcounter(struct proc *td, void *syscall_args)
+{
+	struct get_ffcounter_args *uap;
+	ffcounter ffcount;
+	int error;
+
+	ffcount = 0;
+	error = 0;
+	uap = (struct get_ffcounter_args *) syscall_args;
+	if ( uap->ffcount == NULL )
+		return -1;
+
+	ffcount = read_ffcounter();
+	error = copyout(&ffcount, uap->ffcount, sizeof(ffcounter));
+
+	if (ffcount == 0)
+		error = -1;
+
+	return (error);
+}
+
+static struct sysent get_ffcounter_sysent = {
+	1,
+	(sy_call_t *) get_ffcounter,
+	AUE_NULL,
+	NULL,
+	0,
+	0
+};
+
+static int get_ffcounter_offset = NO_SYSCALL;
+
+static int
+get_ffcounter_load (struct module *module, int cmd, void *arg)
+{
+	int error;
+
+	error = 0;
+	switch (cmd) {
+	case MOD_LOAD :
+		printf("get_ffcounter syscall loaded at %d \n", get_ffcounter_offset);
+		break;
+	case MOD_UNLOAD :
+		printf("get_ffcounter syscall unloaded from %d\n", get_ffcounter_offset);
+		break;
+	default :
+		error = EINVAL;
+		break;
+	}
+	return (error);
+}
+
+/*
+ * XXX we used to call SYSCALL_MODULE to help us with declaring the modules.
+ * Starting with FreeBSD 8.1, the module name was prepended with "sys/" in the
+ * moduledata_t structure. To avoid yet another naming issues, we do
+ * SYSCALL_MODULE's work instead and overwrite this convention.
+ * See /usr/src/sys/sys/sysent.h for the details.
+ *
+ * Hopefully, this will disappear once we go mainstream
+ */
+//SYSCALL_MODULE(get_ffcounter, &get_ffcounter_offset, &get_ffcounter_sysent, get_ffcounter_load, NULL);
+
+static struct syscall_module_data get_ffcounter_syscall_mod = {
+	get_ffcounter_load,
+	NULL,
+	&get_ffcounter_offset,
+	&get_ffcounter_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t get_ffcounter_mod = {
+	"get_ffcounter",
+	syscall_module_handler,
+	&get_ffcounter_syscall_mod
+};
+
+DECLARE_MODULE(get_ffcounter, get_ffcounter_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+/*
+ * System call to push clock parameters to the kernel
+ */
+struct set_ffclock_args {
+	struct ffclock_estimate *cest;
+};
+
+
+/*
+ * Adjust the ffclock by writing down the clock estimates passed from userland.
+ * Hold ffclock_mtx to prevent several instances to update concurrently,
+ * essentially to protect from user's bad practice.
+ * update_ffclock() may bump the generation number without us knowing.
+ *
+ * XXX update comment to reflect what the code does.
+ * mention that updates are acted upon during tc_windup, leading to a delay <= 1/HZ
+ */
+static int set_ffclock(struct proc *td, void *syscall_args)
+{
+	struct set_ffclock_args *uap;
+	int error;
+
+	error = 0;
+	uap = (struct set_ffclock_args *) syscall_args;
+	if ( uap->cest == NULL )
+		return (-1);
+
+	mtx_lock(&ffclock_mtx);
+	error = copyin(uap->cest, &(ffclock), sizeof(struct ffclock_estimate));
+	ffclock_fetch_update = 1;
+	mtx_unlock(&ffclock_mtx);
+
+	return (error);
+}
+
+static struct sysent set_ffclock_sysent = {
+	1,
+	(sy_call_t *) set_ffclock,
+	AUE_NULL,
+	NULL,
+	0,
+	0
+};
+
+static int set_ffclock_offset = NO_SYSCALL;
+
+static int
+set_ffclock_load (struct module *module, int cmd, void *arg)
+{
+	int error;
+
+	error = 0;
+	switch (cmd) {
+	case MOD_LOAD :
+		mtx_init(&ffclock_mtx, "ffclock lock", NULL, MTX_DEF);
+		printf("set_ffclock syscall loaded at %d \n", set_ffclock_offset);
+		break;
+	case MOD_UNLOAD :
+		mtx_destroy(&ffclock_mtx);
+		printf("set_ffclock syscall unloaded from %d\n", set_ffclock_offset);
+		break;
+	default :
+		error = EINVAL;
+		break;
+	}
+	return (error);
+}
+
+/*
+ * XXX we used to call SYSCALL_MODULE to help us with declaring the modules.
+ * Starting with FreeBSD 8.1, the module name was prepended with "sys/" in the
+ * moduledata_t structure. To avoid yet another naming issues, we do
+ * SYSCALL_MODULE's work instead and overwrite this convention.
+ * See /usr/src/sys/sys/sysent.h for the details.
+ *
+ * Hopefully, this will disappear once we go mainstream
+ */
+//SYSCALL_MODULE(set_ffclock, &set_ffclock_offset, &set_ffclock_sysent, set_ffclock_load, NULL);
+
+static struct syscall_module_data set_ffclock_syscall_mod = {
+	set_ffclock_load,
+	NULL,
+	&set_ffclock_offset,
+	&set_ffclock_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t set_ffclock_mod = {
+	"set_ffclock",
+	syscall_module_handler,
+	&set_ffclock_syscall_mod
+};
+
+DECLARE_MODULE(set_ffclock, set_ffclock_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
Index: sys/modules/Makefile
===================================================================
--- sys.orig/modules/Makefile	2011-03-30 14:20:24.000000000 +1100
+++ sys/modules/Makefile	2011-03-30 15:40:33.000000000 +1100
@@ -90,20 +90,21 @@ SUBDIR=	${_3dfx} \
 	${_et} \
 	${_ex} \
 	${_exca} \
 	${_ext2fs} \
 	fatm \
 	fdc \
 	fdescfs \
 	${_fe} \
 	firewire \
 	firmware \
+	ffclock \
 	fxp \
 	gem \
 	geom \
 	${_glxsb} \
 	hatm \
 	hifn \
 	hme \
 	${_hptiop} \
 	${_hptmv} \
 	${_hptrr} \
Index: sys/modules/ffclock/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sys/modules/ffclock/Makefile	2011-03-30 15:43:51.000000000 +1100
@@ -0,0 +1,10 @@
+# This make file creates the .ko module for retrieving the vitual counter through syscall.
+
+.PATH: ${.CURDIR}/../../kern
+
+KMOD=	ffclock
+SRCS=	ffclock.c
+
+SRCS+=	opt_ffclock.h
+
+.include <bsd.kmod.mk>
