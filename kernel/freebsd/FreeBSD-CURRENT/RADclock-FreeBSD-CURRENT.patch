Support for the RADclock and cumulative virtual timecounter
Freebsd Kernel patch: FreeBSD-CURRENT
Julien Ridoux
julien@synclab.org

diff -aur --unidirectional-new-file sys/amd64/amd64/tsc.c FreeBSD-CURRENT/amd64/amd64/tsc.c
--- sys/amd64/amd64/tsc.c	2010-12-09 15:14:25.000000000 +1100
+++ FreeBSD-CURRENT/amd64/amd64/tsc.c	2010-12-09 15:22:45.000000000 +1100
@@ -69,6 +69,18 @@
 static	unsigned tsc_get_timecount(struct timecounter *tc);
 static void tsc_levels_changed(void *arg, int unit);
 
+#ifdef FFCLOCK
+static uint64_t tsc_get_timecount_64(struct timecounter *tc);
+static struct timecounter tsc_timecounter = {
+	.tc_get_timecount = tsc_get_timecount,
+	.tc_poll_pps = 0,
+	.tc_counter_mask = ~0u,
+	.tc_frequency = 0,
+	.tc_name = "TSC",
+	.tc_quality = 800,
+	.tc_get_timecount_64 = &tsc_get_timecount_64
+};
+#else
 static struct timecounter tsc_timecounter = {
 	tsc_get_timecount,	/* get_timecount */
 	0,			/* no poll_pps */
@@ -77,6 +89,7 @@
 	"TSC",			/* name */
 	800,			/* quality (adjusted in code) */
 };
+#endif
 
 void
 init_TSC(void)
@@ -229,3 +242,11 @@
 {
 	return (rdtsc());
 }
+
+#ifdef FFCLOCK
+static uint64_t
+tsc_get_timecount_64(struct timecounter *tc)
+{
+	return (rdtsc());
+}
+#endif
diff -aur --unidirectional-new-file sys/conf/NOTES FreeBSD-CURRENT/conf/NOTES
--- sys/conf/NOTES	2010-12-09 15:14:29.000000000 +1100
+++ FreeBSD-CURRENT/conf/NOTES	2010-12-09 15:22:45.000000000 +1100
@@ -1178,6 +1178,16 @@
 
 options 	PPS_SYNC
 
+# Enable support for generic Feed-Forward clocks in the kernel.
+# The feed-forward clock support is an alternative to the feedback oriented
+# ntpd/system clock approach, and is to be used with a feed-forward
+# synchronization algorithm such as the RADclock:
+# More info there: http://www.synclab.org/radclock
+#
+# Note: this is an experimental feature.
+
+options 	FFCLOCK
+
 
 #####################################################################
 # SCSI DEVICES
diff -aur --unidirectional-new-file sys/conf/options FreeBSD-CURRENT/conf/options
--- sys/conf/options	2010-12-09 15:14:29.000000000 +1100
+++ FreeBSD-CURRENT/conf/options	2010-12-09 15:22:45.000000000 +1100
@@ -75,6 +75,7 @@
 CY_PCI_FASTINTR
 DEADLKRES	opt_watchdog.h
 DIRECTIO
+FFCLOCK		opt_ffclock.h
 FULL_PREEMPTION	opt_sched.h
 IPI_PREEMPTION	opt_sched.h
 GEOM_AES	opt_geom.h
diff -aur --unidirectional-new-file sys/dev/e1000/if_em.c FreeBSD-CURRENT/dev/e1000/if_em.c
--- sys/dev/e1000/if_em.c	2010-12-09 15:14:35.000000000 +1100
+++ FreeBSD-CURRENT/dev/e1000/if_em.c	2010-12-09 15:22:46.000000000 +1100
@@ -251,7 +251,10 @@
 static void	em_register_vlan(void *, struct ifnet *, u16);
 static void	em_unregister_vlan(void *, struct ifnet *, u16);
 static void	em_setup_vlan_hw_support(struct adapter *);
-static int	em_xmit(struct tx_ring *, struct mbuf **);
+
+// jrid
+//static int	em_xmit(struct tx_ring *, struct mbuf **);
+static int	em_xmit(struct tx_ring *, struct mbuf **, struct ifnet *);
 static int	em_dma_malloc(struct adapter *, bus_size_t,
 		    struct em_dma_alloc *, int);
 static void	em_dma_free(struct adapter *, struct em_dma_alloc *);
@@ -846,14 +849,17 @@
 
 	/* Process the queue */
 	while (next != NULL) {
-		if ((err = em_xmit(txr, &next)) != 0) {
+// jrid
+//		if ((err = em_xmit(txr, &next)) != 0) {
+		if ((err = em_xmit(txr, &next, ifp)) != 0) {
                         if (next != NULL)
                                 err = drbr_enqueue(ifp, txr->br, next);
                         break;
 		}
 		enq++;
 		drbr_stats_update(ifp, next->m_pkthdr.len, next->m_flags);
-		ETHER_BPF_MTAP(ifp, next);
+// jrid
+//		ETHER_BPF_MTAP(ifp, next);
 		if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0)
                         break;
 		if (txr->tx_avail < EM_MAX_SCATTER) {
@@ -942,7 +948,10 @@
 		 *  Encapsulation can modify our pointer, and or make it
 		 *  NULL on failure.  In that event, we can't requeue.
 		 */
-		if (em_xmit(txr, &m_head)) {
+// jrid
+// To be able to call BPF_MTAP from em_xmit
+//		if (em_xmit(txr, &m_head)) {
+		if (em_xmit(txr, &m_head, ifp)) {
 			if (m_head == NULL)
 				break;
 			ifp->if_drv_flags |= IFF_DRV_OACTIVE;
@@ -951,7 +960,11 @@
 		}
 
 		/* Send a copy of the frame to the BPF listener */
-		ETHER_BPF_MTAP(ifp, m_head);
+// jrid
+// This call after em_xmit() does not preserve causality
+// If called before em_xmit() (which can fail) takes the risk to send 2 copies of the
+// same packet. Need to move it into em_xmit()
+//		ETHER_BPF_MTAP(ifp, m_head);
 
 		/* Set timeout in case hardware has problems transmitting. */
 		txr->watchdog_time = ticks;
@@ -1743,8 +1756,11 @@
  *  return 0 on success, positive on failure
  **********************************************************************/
 
+// jrid
+//static int
+//em_xmit(struct tx_ring *txr, struct mbuf **m_headp)
 static int
-em_xmit(struct tx_ring *txr, struct mbuf **m_headp)
+em_xmit(struct tx_ring *txr, struct mbuf **m_headp, struct ifnet *ifp)
 {
 	struct adapter		*adapter = txr->adapter;
 	bus_dma_segment_t	segs[EM_MAX_SCATTER];
@@ -2034,6 +2050,9 @@
 	/* Update the watchdog time early and often */
 	txr->watchdog_time = ticks;
 
+// jrid
+// This cannot fail
+		ETHER_BPF_MTAP(ifp, m_head);
 	/*
 	 * Advance the Transmit Descriptor Tail (TDT), this tells the E1000
 	 * that this frame is available to transmit.
@@ -4071,7 +4090,10 @@
 	 * Set the interrupt throttling rate. Value is calculated
 	 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns)
 	 */
-	E1000_WRITE_REG(hw, E1000_ITR, DEFAULT_ITR);
+// jrid
+// Disable any type of interrupt throttling
+//	E1000_WRITE_REG(hw, E1000_ITR, DEFAULT_ITR);
+	E1000_WRITE_REG(hw, E1000_ITR, 0);
 
 	/*
 	** When using MSIX interrupts we need to throttle
diff -aur --unidirectional-new-file sys/i386/i386/tsc.c FreeBSD-CURRENT/i386/i386/tsc.c
--- sys/i386/i386/tsc.c	2010-12-09 15:14:40.000000000 +1100
+++ FreeBSD-CURRENT/i386/i386/tsc.c	2010-12-09 15:22:45.000000000 +1100
@@ -70,6 +70,18 @@
 static	unsigned tsc_get_timecount(struct timecounter *tc);
 static void tsc_levels_changed(void *arg, int unit);
 
+#ifdef FFCLOCK
+static uint64_t tsc_get_timecount_64(struct timecounter *tc);
+static struct timecounter tsc_timecounter = {
+	.tc_get_timecount = tsc_get_timecount,
+	.tc_poll_pps = 0,
+	.tc_counter_mask = ~0u,
+	.tc_frequency = 0,
+	.tc_name = "TSC",
+	.tc_quality = 800,
+	.tc_get_timecount_64 = &tsc_get_timecount_64
+};
+#else
 static struct timecounter tsc_timecounter = {
 	tsc_get_timecount,	/* get_timecount */
 	0,			/* no poll_pps */
@@ -78,6 +90,7 @@
 	"TSC",			/* name */
 	800,			/* quality (adjusted in code) */
 };
+#endif
 
 void
 init_TSC(void)
@@ -257,3 +270,11 @@
 {
 	return (rdtsc());
 }
+
+#ifdef FFCLOCK
+static uint64_t
+tsc_get_timecount_64(struct timecounter *tc)
+{
+	return (rdtsc());
+}
+#endif
diff -aur --unidirectional-new-file sys/i386/xen/clock.c FreeBSD-CURRENT/i386/xen/clock.c
--- sys/i386/xen/clock.c	2010-12-09 15:14:40.000000000 +1100
+++ FreeBSD-CURRENT/i386/xen/clock.c	2010-12-09 15:22:45.000000000 +1100
@@ -292,6 +292,19 @@
 
 static	unsigned xen_get_timecount(struct timecounter *tc);
 
+#ifdef FFCLOCK
+static uint64_t xen_get_timecount_64(struct timecounter *tc);
+
+static struct timecounter xen_timecounter = {
+	.tc_get_timecount = xen_get_timecount,
+	.tc_poll_pps = 0,
+	.tc_counter_mask = ~0u,
+	.tc_frequency = 0,
+	.tc_name = "ixen",
+	.tc_quality = 0,
+	.tc_get_timecount_64 = &xen_get_timecount_64 
+};
+#else
 static struct timecounter xen_timecounter = {
 	xen_get_timecount,	/* get_timecount */
 	0,			/* no poll_pps */
@@ -300,6 +313,7 @@
 	"ixen",			/* name */
 	0			/* quality */
 };
+#endif
 
 static int
 clkintr(void *arg)
@@ -833,6 +847,21 @@
 
 }
 
+#ifdef FFCLOCK
+static uint64_t
+xen_get_timecount_64(struct timecounter *tc)
+{	
+	uint64_t clk;
+	struct shadow_time_info *shadow;
+	shadow = &per_cpu(shadow_time, smp_processor_id());
+
+	__get_time_values_from_xen();
+	clk = shadow->system_timestamp + get_nsec_offset(shadow);
+
+	return clk;
+}
+#endif
+
 /* Return system time offset by ticks */
 uint64_t
 get_system_time(int ticks)
diff -aur --unidirectional-new-file sys/kern/kern_tc.c FreeBSD-CURRENT/kern/kern_tc.c
--- sys/kern/kern_tc.c	2010-12-09 15:14:41.000000000 +1100
+++ FreeBSD-CURRENT/kern/kern_tc.c	2010-12-09 15:22:45.000000000 +1100
@@ -21,6 +21,13 @@
 #include <sys/timetc.h>
 #include <sys/timex.h>
 
+#ifdef FFCLOCK
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/malloc.h>
+#endif	/* FFCLOCK */
+
+
 /*
  * A large step happens on boot.  This constant detects such steps.
  * It is relatively small so that ntp_update_second gets called enough
@@ -53,6 +60,11 @@
 	int64_t			th_adjustment;
 	uint64_t		th_scale;
 	u_int	 		th_offset_count;
+
+#ifdef FFCLOCK
+	ffcounter_t		ffcounter_record;
+#endif
+
 	struct bintime		th_offset;
 	struct timeval		th_microtime;
 	struct timespec		th_nanotime;
@@ -61,6 +73,30 @@
 	struct timehands	*th_next;
 };
 
+#ifdef FFCLOCK
+static struct timehands th0;
+static struct timehands th9 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th0};
+static struct timehands th8 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th9};
+static struct timehands th7 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th8};
+static struct timehands th6 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th7};
+static struct timehands th5 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th6};
+static struct timehands th4 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th5};
+static struct timehands th3 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th4};
+static struct timehands th2 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th3};
+static struct timehands th1 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th2};
+static struct timehands th0 = {
+	&dummy_timecounter,
+	0,
+	(uint64_t)-1 / 1000000,
+	0,
+	0,
+	{1, 0},
+	{0, 0},
+	{0, 0},
+	1,
+	&th1
+};
+#else
 static struct timehands th0;
 static struct timehands th9 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th0};
 static struct timehands th8 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th9};
@@ -82,6 +118,7 @@
 	1,
 	&th1
 };
+#endif	/* FFCLOCK */
 
 static struct timehands *volatile timehands = &th0;
 struct timecounter *timecounter = &dummy_timecounter;
@@ -163,6 +200,251 @@
  * the comment in <sys/time.h> for a description of these 12 functions.
  */
 
+#ifdef FFCLOCK
+static int sysctl_kern_timecounter_passthrough = 0;
+SYSCTL_INT(_kern_timecounter, OID_AUTO, passthrough, CTLFLAG_RW,
+	&sysctl_kern_timecounter_passthrough, 0,
+	"Select universal Feed-Forward timecounter for OS virtualization");
+
+
+/* Global data structure containing clock estimates */ 
+static struct feedforward_clock ffclock;
+
+MALLOC_DECLARE(M_FFCLOCK);
+MALLOC_DEFINE(M_FFCLOCK, "FFCLOCK", "Feed-Forward Clock estimates");
+
+
+static void
+init_ffclock(struct feedforward_clock *ffclock)
+{
+	unsigned long sz;
+	sz = sizeof(struct ffclock_estimate);
+
+	ffclock->updated = 0;
+	ffclock->cest	= (struct ffclock_estimate *) malloc(sz, M_FFCLOCK, M_WAITOK | M_ZERO);
+	ffclock->ocest	= (struct ffclock_estimate *) malloc(sz, M_FFCLOCK, M_WAITOK | M_ZERO);
+	ffclock->ucest	= (struct ffclock_estimate *) malloc(sz, M_FFCLOCK, M_WAITOK | M_ZERO);
+}
+
+
+/* 
+ * We need to have a boot time from the RTC clock or the like to get 
+ * kickstarted. init_ffclock is called before inittodr(), so cannot put the code
+ * there. Need to be called from tc_setclock(), once only.
+ */
+static void
+reset_ffclock(struct feedforward_clock *ffclock, struct timehands *th)
+{
+	uint64_t freq;
+	struct timecounter *tc;
+	struct ffclock_estimate *cest;
+	struct ffclock_data *cdata;
+
+	cest = ffclock->ucest;
+	cdata = &(cest->cdata);
+
+	/*
+	 * If called with a timehand, the timecounter is being changed and we
+	 * restart fresh. If not, the clock is being set from tc_setclock (note that
+	 * this may occur several times during boot).
+	 */ 
+	if (th) {
+		th->ffcounter_record = 0;
+		cdata->ffcounter = 0;
+		tc = th->th_counter;
+	}
+	else {
+		/* 
+		 * Strictly speaking, we should record the ffcounter when the RTC clock is
+		 * read from initoddr(), but not worse the trouble (is RTC trustworthy
+		 * anyway?). Let's keep it simple
+		 */ 
+		cdata->ffcounter = read_ffcounter();
+		tc = timehands->th_counter;
+	}
+	freq = tc->tc_frequency;
+
+	/* Numbers here are a bit magic */
+	// TODO should check these values ... again
+	cdata->phat_shift = 58;
+	cdata->time_shift = 32;
+	cdata->countdiff_maxbits = 30;
+
+	cdata->phat_int = ((1LL << 63) / freq) >> (63 - cdata->phat_shift); 
+
+	cdata->time_int = (boottimebin.sec << cdata->time_shift)
+		+ (boottimebin.frac >> (64 - cdata->time_shift));
+
+	if (++cest->gen == 0)
+		cest->gen = 1;
+
+	ffclock->ucest = ffclock->cest;
+	ffclock->cest = cest;
+	
+	cdata = &(ffclock->cest->cdata);
+	printf("reset_ffclock: %s - phat_int = %llu (%llu Hz), time_int = %llu (%llu.%llu s)\n",
+			tc->tc_name,
+			(long long unsigned) cdata->phat_int,
+			(long long unsigned) freq,
+			(long long unsigned) cdata->time_int,
+			(long long unsigned) boottimebin.sec, 
+			(long long unsigned) boottimebin.frac);
+
+	/* XXX Technically, should lock, but if radclock module not loaded?
+	 * Also, should make the radclock restart if the counter has changed!!
+	 */	
+}
+
+
+/* 
+ * Update to prevent overflow. This is no adjustment of the clock parameters.
+ * Assumption: timehands is the current one
+ */
+static void
+update_ffclock(struct feedforward_clock *ffclock)
+{
+	struct ffclock_estimate *tmp;
+	struct ffclock_data *cdata;
+	struct timehands *th;
+	ffcounter_t cdiff;
+
+	/*
+	 * If the clock has been updated by the synchronisation daemon, this new
+	 * data is the more up to date one.
+	 */
+	if ( ffclock->updated )
+	{
+		ffclock->ucest->gen = ffclock->cest->gen;
+		if (++ffclock->ucest->gen == 0)
+			ffclock->ucest->gen = 1;
+
+		tmp = ffclock->cest;
+		ffclock->cest = ffclock->ucest;
+		ffclock->ucest = tmp;
+		ffclock->updated = 0;
+		return;
+	}
+
+	/*
+	 * If we just changed the timecounter, we have nothing to do in here
+	 */
+	cdata = &(ffclock->cest->cdata);
+	th = timehands;
+	if ( cdata->ffcounter > th->ffcounter_record )
+		return;
+
+	/*
+	 * Update time mark 
+	 */
+	*(ffclock->ocest) = *(ffclock->cest);	
+	cdata = &(ffclock->ocest->cdata);
+
+	cdiff = th->ffcounter_record - cdata->ffcounter;
+	cdata->time_int += ((cdata->phat_int * cdiff) >> (cdata->phat_shift - cdata->time_shift));
+	cdata->ffcounter = th->ffcounter_record;
+	if (++ffclock->ocest->gen == 0)
+		ffclock->ocest->gen = 1;
+
+	tmp = ffclock->cest;
+	ffclock->cest = ffclock->ocest;
+	ffclock->ocest = tmp;
+}
+
+
+
+void
+ffcounter2bintime(ffcounter_t *ffcounter, struct bintime *bt)
+{
+	ffcounter_t countdiff;
+	uint64_t time_f;
+	uint64_t frac;
+	struct ffclock_data *cdata;
+	uint8_t gen;
+
+	/* Synchronization algorithm (userland) should update the fixed point data
+	 * often enough to make sure the timeval does not overflow. If no sync algo
+	 * updates the data, we loose precision, but in that case, nobody is tracking
+	 * the clock drift anyway ... so send warning and stop worrying.
+	 */
+
+	/* No locking to prevent clock data to be updated. Check that the generation
+	 * has not changed instead.
+	 */
+	do {
+		gen = ffclock.cest->gen;
+		cdata = &(ffclock.cest->cdata);
+
+		countdiff = *ffcounter - cdata->ffcounter;
+
+		/*
+		 * update_ffclock() should prevent countdiff to become to large and the
+		 * corresponding time interval added to overflow. Just send warning in
+		 * the unlikely event this is happening.
+		 */
+		if (countdiff & ~((1ll << (cdata->countdiff_maxbits +1)) - 1))
+		{
+			printf("ffclock: warning stamp may overflow timeval at %llu! "
+					"(countdiff = %llu, maxbits = %u)\n", 
+					(long long unsigned) *ffcounter,
+					(long long unsigned) countdiff,
+					cdata->countdiff_maxbits);
+		}
+		/* Add the counter delta in second to the recorded fixed point time */
+		time_f 	= cdata->time_int
+			+ ((cdata->phat_int * countdiff) >> (cdata->phat_shift - cdata->time_shift));
+
+		bt->sec  = time_f >> cdata->time_shift;
+
+/*
+		printf("ffclock: ffcounter = %llu bt->sec = %llu, time_int = %llu\n",
+				(long long unsigned) *ffcounter,
+			   	(long long unsigned) bt->sec, 
+				(long long unsigned) (cdata->time_int >> cdata->time_shift));
+*/
+		// gives me headaches again
+		// frac * ( 2^64 - 2^time_shift) ... that should be the correct resolution
+		frac = time_f - ((uint64_t) bt->sec << cdata->time_shift);
+		bt->frac = frac * ((uint64_t) 1LL << (64 - cdata->time_shift));
+
+	} while (gen == 0 || gen != ffclock.cest->gen);
+}
+
+
+static __inline uint64_t
+tc_get_timecount_fake64(struct timecounter *tc)
+{
+	u_int count;
+	count = tc->tc_get_timecount(tc);
+	return (uint64_t) count;
+}
+
+
+ffcounter_t
+read_ffcounter(void)
+{
+	struct timecounter *tc;
+	struct timehands *th;
+	u_int gen, delta;
+	ffcounter_t ffcounter;
+
+	if ( sysctl_kern_timecounter_passthrough ) {
+		tc = timehands->th_counter;
+		return tc->tc_get_timecount_64(tc);
+	}
+	else {
+		do {
+			th = timehands;
+			gen = th->th_generation;
+			delta = tc_delta(th);
+			ffcounter = th->ffcounter_record;
+		} while ( gen == 0 || gen != th->th_generation);
+
+		return(ffcounter + delta);
+	}
+}
+#endif	/* FFCLOCK */
+
+
 void
 binuptime(struct bintime *bt)
 {
@@ -325,7 +607,13 @@
 		    tc->tc_name, (uintmax_t)tc->tc_frequency,
 		    tc->tc_quality);
 	}
-
+#ifdef FFCLOCK
+	/* XXX this is a very ugly but good enough to cover my back */
+	if ( (strcmp(tc->tc_name, "TSC") != 0) && (strcmp(tc->tc_name, "ixen") != 0) )
+	{
+		tc->tc_get_timecount_64 = &tc_get_timecount_fake64;
+	}
+#endif
 	tc->tc_next = timecounters;
 	timecounters = tc;
 	/*
@@ -391,6 +679,10 @@
 	boottimebin = bt;
 	bintime2timeval(&bt, &boottime);
 
+#ifdef FFCLOCK
+	reset_ffclock(&ffclock, NULL);
+#endif	/* FFCLOCK */
+
 	/* XXX fiddle all the little crinkly bits around the fiords... */
 	tc_windup();
 	nanotime(&taft);
@@ -440,6 +732,11 @@
 		ncount = timecounter->tc_get_timecount(timecounter);
 	else
 		ncount = 0;
+
+#ifdef FFCLOCK
+	th->ffcounter_record += delta;
+#endif
+
 	th->th_offset_count += delta;
 	th->th_offset_count &= th->th_counter->tc_counter_mask;
 	bintime_addx(&th->th_offset, th->th_scale * delta);
@@ -486,6 +783,10 @@
 		th->th_offset_count = ncount;
 		tc_min_ticktock_freq = max(1, timecounter->tc_frequency /
 		    (((uint64_t)timecounter->tc_counter_mask + 1) / 3));
+
+		#ifdef FFCLOCK
+		reset_ffclock(&ffclock, th);
+		#endif
 	}
 
 	/*-
@@ -528,6 +829,11 @@
 	time_second = th->th_microtime.tv_sec;
 	time_uptime = th->th_offset.sec;
 	timehands = th;
+
+
+#ifdef FFCLOCK
+	update_ffclock(&ffclock);
+#endif
 }
 
 /* Report or change the active timecounter hardware. */
@@ -594,6 +900,10 @@
 {
 	pps_params_t *app;
 	struct pps_fetch_args *fapi;
+#ifdef FFCLOCK
+	struct ffclock_pps_fetch_args *ffclock_fapi;
+#endif
+
 #ifdef PPS_SYNC
 	struct pps_kcbind_args *kapi;
 #endif
@@ -627,6 +937,19 @@
 		pps->ppsinfo.current_mode = pps->ppsparam.mode;
 		fapi->pps_info_buf = pps->ppsinfo;
 		return (0);
+
+#ifdef FFCLOCK
+	case FFCLOCK_PPS_IOC_FETCH:
+		ffclock_fapi = (struct ffclock_pps_fetch_args *)data;
+		if (ffclock_fapi->tsformat && ffclock_fapi->tsformat != PPS_TSFMT_TSPEC)
+			return (EINVAL);
+		if (ffclock_fapi->timeout.tv_sec || ffclock_fapi->timeout.tv_nsec)
+			return (EOPNOTSUPP);
+		pps->ppsinfo.current_mode = pps->ppsparam.mode;
+		ffclock_fapi->pps_info_buf = pps->ffclock_ppsinfo;
+		return (0);
+#endif 	/* FFCLOCK */
+
 	case PPS_IOC_KCBIND:
 #ifdef PPS_SYNC
 		kapi = (struct pps_kcbind_args *)data;
@@ -679,6 +1002,12 @@
 	u_int tcount, *pcount;
 	int foff, fhard;
 	pps_seq_t *pseq;
+#ifdef FFCLOCK
+	struct timespec *ffclock_tsp;
+	pps_seq_t *ffclock_pseq;
+	ffcounter_t *ffcounter;
+	ffcounter_t ffcounter_record;
+#endif
 
 	KASSERT(pps != NULL, ("NULL pps pointer in pps_event"));
 	/* If the timecounter was wound up underneath us, bail out. */
@@ -693,6 +1022,11 @@
 		fhard = pps->kcmode & PPS_CAPTUREASSERT;
 		pcount = &pps->ppscount[0];
 		pseq = &pps->ppsinfo.assert_sequence;
+#ifdef FFCLOCK
+		ffcounter = &pps->ffclock_ppsinfo.assert_ffcounter;
+		ffclock_tsp = &pps->ffclock_ppsinfo.assert_timestamp;
+		ffclock_pseq = &pps->ffclock_ppsinfo.assert_sequence;
+#endif
 	} else {
 		tsp = &pps->ppsinfo.clear_timestamp;
 		osp = &pps->ppsparam.clear_offset;
@@ -700,6 +1034,11 @@
 		fhard = pps->kcmode & PPS_CAPTURECLEAR;
 		pcount = &pps->ppscount[1];
 		pseq = &pps->ppsinfo.clear_sequence;
+#ifdef FFCLOCK
+		ffcounter = &pps->ffclock_ppsinfo.clear_ffcounter;
+		ffclock_tsp = &pps->ffclock_ppsinfo.clear_timestamp;
+		ffclock_pseq = &pps->ffclock_ppsinfo.clear_sequence;
+#endif
 	}
 
 	/*
@@ -716,6 +1055,9 @@
 	/* Convert the count to a timespec. */
 	tcount = pps->capcount - pps->capth->th_offset_count;
 	tcount &= pps->capth->th_counter->tc_counter_mask;
+#ifdef FFCLOCK
+	ffcounter_record = pps->capth->ffcounter_record;
+#endif
 	bt = pps->capth->th_offset;
 	bintime_addx(&bt, pps->capth->th_scale * tcount);
 	bintime_add(&bt, &boottimebin);
@@ -728,6 +1070,11 @@
 	*pcount = pps->capcount;
 	(*pseq)++;
 	*tsp = ts;
+#ifdef FFCLOCK
+	(*ffclock_pseq)++;
+	*ffclock_tsp = ts;
+	*ffcounter = (ffcounter_record + tcount);
+#endif
 
 	if (foff) {
 		timespecadd(tsp, osp);
@@ -802,6 +1149,10 @@
 	p = (tc_tick * 1000000) / hz;
 	printf("Timecounters tick every %d.%03u msec\n", p / 1000, p % 1000);
 
+#ifdef FFCLOCK
+	init_ffclock(&ffclock);
+#endif
+
 	/* warm up new timecounter (again) and get rolling. */
 	(void)timecounter->tc_get_timecount(timecounter);
 	(void)timecounter->tc_get_timecount(timecounter);
diff -aur --unidirectional-new-file sys/kern/radclock.c FreeBSD-CURRENT/kern/radclock.c
--- sys/kern/radclock.c	1970-01-01 10:00:00.000000000 +1000
+++ FreeBSD-CURRENT/kern/radclock.c	2010-12-09 15:22:45.000000000 +1100
@@ -0,0 +1,347 @@
+/*-
+ * Copyright (C) 2010 University of Melbourne
+ * All rights reserved.
+ *
+ * This software was developed by the University of Melbourne under sponsorship from
+ * the FreeBSD Foundation.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ * 2. Redistributions in binary form must reproduce the above copyright 
+ *    notice, this list of conditions and the following disclaimer in the 
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+/*
+ * System calls to access the cumulative virtual timecounter
+ */
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/proc.h>
+#include <sys/module.h>
+#include <sys/sysent.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/time.h>
+#include <sys/sysproto.h>
+#include <sys/bus.h>
+#include <sys/sysctl.h>
+
+
+extern struct feedforward_clock ffclock;
+
+static struct mtx ffclock_mtx;	/* lock against concurrent updates of the ffclock estimates */
+
+/*
+ * Sysctl
+ */
+static int ffclock_version = 2;
+
+SYSCTL_NODE(_kern, OID_AUTO, ffclock, CTLFLAG_RW, 0, "Feed-Forward Clock Support");
+SYSCTL_INT(_kern_ffclock, OID_AUTO, version, CTLFLAG_RD, &ffclock_version, 0, "Version of Feed-Forward Clock Support");
+
+
+/*
+ * First system call is get_ffcounter to retrieve the current value
+ * of the cumulative vritual counter from the timecounter interface
+ */
+
+struct get_ffcounter_args {
+	ffcounter_t *ffcounter;
+};
+
+static int
+get_ffcounter(struct proc *td, void *syscall_args)
+{
+	ffcounter_t ffcounter = 0;
+	int error = 0;
+	struct get_ffcounter_args *uap;
+
+	uap = (struct get_ffcounter_args *) syscall_args;
+	if ( uap->ffcounter == NULL )
+		return -1;
+	
+	ffcounter = read_ffcounter();
+	error = copyout(&ffcounter, uap->ffcounter, sizeof(ffcounter_t));
+	
+	if ( ffcounter == 0 ) 
+		error = -1;
+
+	return(error);
+}
+
+
+static struct sysent get_ffcounter_sysent = {
+	1,
+	(sy_call_t *) get_ffcounter,
+	AUE_NULL, 
+	NULL, 
+	0, 
+	0 
+};
+
+
+static int get_ffcounter_offset = NO_SYSCALL;
+
+static int
+get_ffcounter_load (struct module *module, int cmd, void *arg)
+{
+	int error = 0;
+	switch (cmd) {
+		case MOD_LOAD :
+			printf("get_ffcounter syscall loaded at %d \n", get_ffcounter_offset);
+		break;
+		case MOD_UNLOAD :
+			printf("get_ffcounter syscall unloaded from %d\n", get_ffcounter_offset);
+		break;
+		default :
+			error = EINVAL;
+		break;
+	}
+	return error;
+}
+
+/*
+ * XXX we used to call SYSCALL_MODULE to help us with declaring the modules.
+ * Starting with FreeBSD 8.1, the module name was prepended with "sys/" in the
+ * moduledata_t structure. To avoid yet another naming issues, we do
+ * SYSCALL_MODULE's work instead and overwrite this convention.
+ * See /usr/src/sys/sys/sysent.h for the details.
+ *
+ * Hopefully, this will disappear once we go mainstream
+ */
+//SYSCALL_MODULE(get_ffcounter, &get_ffcounter_offset, &get_ffcounter_sysent, get_ffcounter_load, NULL);
+
+static struct syscall_module_data get_ffcounter_syscall_mod = {
+	get_ffcounter_load,
+	NULL,
+	&get_ffcounter_offset,
+	&get_ffcounter_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t get_ffcounter_mod = {
+	"get_ffcounter",
+	syscall_module_handler,
+	&get_ffcounter_syscall_mod
+};
+
+DECLARE_MODULE(get_ffcounter, get_ffcounter_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+
+
+
+/*
+ * Second system call is get_ffcounter_latency to compute the latency of
+ * the timecounter interface from within the kernel
+ *
+ * XXX: of course this makes sense ONLY if we have a stable TSC
+ * (i.e. no SMP, no power management, no frequency jumps etc.) 
+ */
+
+struct get_ffcounter_latency_args {
+	ffcounter_t *ffcounter;
+	uint64_t *ffcounter_lat;
+	uint64_t *tsc_lat;
+};
+
+static int
+get_ffcounter_latency(struct proc *td, void *syscall_args)
+{
+	uint64_t tsc1 = 0, tsc2 = 0, tsc3 = 0, ffcounter_lat = 0, tsc_lat = 0;
+	ffcounter_t ffcounter;
+	int error = 0;
+	struct get_ffcounter_latency_args *uap;
+
+	uap = (struct get_ffcounter_latency_args *) syscall_args;
+
+	/* One for fun and warmup */
+	tsc1 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+	tsc1 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+	tsc2 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+	ffcounter = read_ffcounter();
+	__asm __volatile("lfence" ::: "memory");
+	tsc3 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+
+	tsc_lat = tsc2 - tsc1;
+	ffcounter_lat = tsc3 - tsc2;
+
+	error += copyout(&ffcounter, uap->ffcounter, sizeof(ffcounter_t));
+	error += copyout(&ffcounter_lat, uap->ffcounter_lat, sizeof(uint64_t));
+	error += copyout(&tsc_lat, uap->tsc_lat, sizeof(uint64_t));
+
+	return(error);
+}
+
+
+static struct sysent get_ffcounter_latency_sysent = {
+	3,
+	(sy_call_t *) get_ffcounter_latency,
+	AUE_NULL, 
+	NULL, 
+	0, 
+	0 
+};
+
+
+static int get_ffcounter_latency_offset = NO_SYSCALL;
+
+static int
+get_ffcounter_latency_load (struct module *module, int cmd, void *arg)
+{
+	int error = 0;
+	switch (cmd) {
+		case MOD_LOAD :
+			printf("get_ffcounter_latency syscall loaded at %d \n", get_ffcounter_latency_offset);
+		break;
+		case MOD_UNLOAD :
+			printf("get_ffcounter_latency syscall unloaded from %d\n", get_ffcounter_latency_offset);
+		break;
+		default :
+			error = EINVAL;
+		break;
+	}
+	return error;
+}
+
+/* See comment above for use of SYSCALL_MODULE before 8.1 */
+//SYSCALL_MODULE(get_ffcounter_latency, &get_ffcounter_latency_offset, &get_ffcounter_latency_sysent, get_ffcounter_latency_load, NULL);
+
+static struct syscall_module_data get_ffcounter_latency_syscall_mod = {
+	get_ffcounter_latency_load,
+	NULL,
+	&get_ffcounter_latency_offset,
+	&get_ffcounter_latency_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t get_ffcounter_latency_mod = {
+	"get_ffcounter_latency",
+	syscall_module_handler,
+	&get_ffcounter_latency_syscall_mod
+};
+
+DECLARE_MODULE(get_ffcounter_latency, get_ffcounter_latency_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+
+
+
+/*
+ * System call to push clock parameters to the kernel 
+ */
+
+struct set_ffclock_args {
+	struct ffclock_data *cdata;
+};
+
+
+/*
+ * Adjust the ffclock by writing down the clock estimates passed from userland.
+ * Hold ffclock_mtx to prevent several instances to update concurrently,
+ * essentially to protect from user's bad practice.
+ * update_ffclock() may bump the generation number without us knowing. 
+ *
+ * XXX update comment to reflect what the code does.
+ * mention that updates are acted upon during tc_windup, leading to a delay <= 1/HZ
+ */
+static int set_ffclock(struct proc *td, void *syscall_args)
+{
+	int error = 0;
+	struct set_ffclock_args *uap;
+
+	uap = (struct set_ffclock_args *) syscall_args;
+	if ( uap->cdata == NULL )
+		return -1;
+
+	mtx_lock(&ffclock_mtx);
+	error = copyin(uap->cdata, &(ffclock.ucest->cdata), sizeof(struct ffclock_data));
+	ffclock.updated = 1;
+	mtx_unlock(&ffclock_mtx);
+
+	return(error);
+}
+
+
+static struct sysent set_ffclock_sysent = {
+	1,
+	(sy_call_t *) set_ffclock,
+	AUE_NULL, 
+	NULL, 
+	0, 
+	0 
+};
+
+
+static int set_ffclock_offset = NO_SYSCALL;
+
+static int
+set_ffclock_load (struct module *module, int cmd, void *arg)
+{
+	int error = 0;
+	switch (cmd) {
+		case MOD_LOAD :
+			mtx_init(&ffclock_mtx, "ffclock lock", NULL, MTX_DEF);
+			printf("set_ffclock syscall loaded at %d \n", set_ffclock_offset);
+		break;
+		case MOD_UNLOAD :
+			mtx_destroy(&ffclock_mtx);
+			printf("set_ffclock syscall unloaded from %d\n", set_ffclock_offset);
+		break;
+		default :
+			error = EINVAL;
+		break;
+	}
+	return error;
+}
+
+/*
+ * XXX we used to call SYSCALL_MODULE to help us with declaring the modules.
+ * Starting with FreeBSD 8.1, the module name was prepended with "sys/" in the
+ * moduledata_t structure. To avoid yet another naming issues, we do
+ * SYSCALL_MODULE's work instead and overwrite this convention.
+ * See /usr/src/sys/sys/sysent.h for the details.
+ *
+ * Hopefully, this will disappear once we go mainstream
+ */
+//SYSCALL_MODULE(set_ffclock, &set_ffclock_offset, &set_ffclock_sysent, set_ffclock_load, NULL);
+
+static struct syscall_module_data set_ffclock_syscall_mod = {
+	set_ffclock_load,
+	NULL,
+	&set_ffclock_offset,
+	&set_ffclock_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t set_ffclock_mod = {
+	"set_ffclock",
+	syscall_module_handler,
+	&set_ffclock_syscall_mod
+};
+
+DECLARE_MODULE(set_ffclock, set_ffclock_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+
diff -aur --unidirectional-new-file sys/modules/Makefile FreeBSD-CURRENT/modules/Makefile
--- sys/modules/Makefile	2010-12-09 15:14:44.000000000 +1100
+++ FreeBSD-CURRENT/modules/Makefile	2010-12-09 15:22:45.000000000 +1100
@@ -241,6 +241,7 @@
 	${_pst} \
 	pty  \
 	puc \
+	radclock \
 	ral \
 	ralfw \
 	${_random} \
diff -aur --unidirectional-new-file sys/modules/radclock/Makefile FreeBSD-CURRENT/modules/radclock/Makefile
--- sys/modules/radclock/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ FreeBSD-CURRENT/modules/radclock/Makefile	2010-12-09 15:22:45.000000000 +1100
@@ -0,0 +1,15 @@
+# This make file creates the .ko module for retrieving the vitual counter through syscall.
+
+.PATH: ${.CURDIR}/../../kern
+
+KMOD    =  radclock
+SRCS    =  radclock.c
+
+SRCS+=	opt_ffclock.h
+
+.if !defined(KERNBUILDDIR)
+opt_ffclock.h:
+	echo "#define FFCLOCK 1" > opt_ffclock.h
+.endif
+
+.include <bsd.kmod.mk>
diff -aur --unidirectional-new-file sys/net/bpf.c FreeBSD-CURRENT/net/bpf.c
--- sys/net/bpf.c	2010-12-09 15:14:44.000000000 +1100
+++ FreeBSD-CURRENT/net/bpf.c	2010-12-09 15:22:45.000000000 +1100
@@ -90,8 +90,13 @@
 
 #define PRINET  26			/* interruptible */
 
+#ifdef FFCLOCK
+#define	SIZEOF_BPF_HDR(type)	\
+    (offsetof(type, ffcounter_stamp) + sizeof(((type *)0)->ffcounter_stamp))
+#else
 #define	SIZEOF_BPF_HDR(type)	\
     (offsetof(type, bh_hdrlen) + sizeof(((type *)0)->bh_hdrlen))
+#endif	/* FFCLOCK */
 
 #ifdef COMPAT_FREEBSD32
 #include <sys/mount.h>
@@ -111,6 +116,10 @@
 	uint32_t	bh_datalen;	/* original length of packet */
 	uint16_t	bh_hdrlen;	/* length of bpf header (this struct
 					   plus alignment padding) */
+#ifdef FFCLOCK
+	u_short     padding;        /* padding to align the fields */
+	ffcounter_t  ffcounter_stamp;   /* raw virtual timecounter timestamp for this packet */      
+#endif
 };
 #endif
 
@@ -151,9 +160,15 @@
 static void	bpf_timed_out(void *);
 static __inline void
 		bpf_wakeup(struct bpf_d *);
+#ifdef FFCLOCK
+static void catchpacket(struct bpf_d *, u_char *, u_int, u_int,
+			void (*)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+			struct bintime *, ffcounter_t *);
+#else
 static void	catchpacket(struct bpf_d *, u_char *, u_int, u_int,
 		    void (*)(struct bpf_d *, caddr_t, u_int, void *, u_int),
 		    struct bintime *);
+#endif
 static void	reset_d(struct bpf_d *);
 static int	 bpf_setf(struct bpf_d *, struct bpf_program *, u_long cmd);
 static int	bpf_getdltlist(struct bpf_d *, struct bpf_dltlist *);
@@ -172,6 +187,11 @@
     &bpf_zerocopy_enable, 0, "Enable new zero-copy BPF buffer sessions");
 SYSCTL_NODE(_net_bpf, OID_AUTO, stats, CTLFLAG_MPSAFE | CTLFLAG_RW,
     bpf_stats_sysctl, "bpf statistics portal");
+#ifdef FFCLOCK
+static int bpf_ffclock_tstamp = 0; 
+SYSCTL_INT(_net_bpf, OID_AUTO, ffclock_tstamp, CTLFLAG_RW,
+	&bpf_ffclock_tstamp, 0, "Set BPF to timestamp using Feed-Forward clock by default");
+#endif /* FFCLOCK */
 
 static	d_open_t	bpfopen;
 static	d_read_t	bpfread;
@@ -698,6 +718,14 @@
 	callout_init_mtx(&d->bd_callout, &d->bd_mtx, 0);
 	knlist_init_mtx(&d->bd_sel.si_note, &d->bd_mtx);
 
+#ifdef FFCLOCK
+	/* Timestamping mode for this device, default is use the system clock.
+	 * Need BPF_T_MONOTONIC to avoid bpf_bintime2ts to add bootime.
+	 */
+	if (bpf_ffclock_tstamp)
+		d->bd_tstamp = d->bd_tstamp | BPF_T_FFCLOCK | BPF_T_MONOTONIC;
+#endif /* FFCLOCK */
+
 	return (0);
 }
 
@@ -1817,6 +1845,9 @@
 #endif
 	u_int slen;
 	int gottime;
+#ifdef FFCLOCK
+	ffcounter_t ffcounter;
+#endif
 
 	gottime = BPF_TSTAMP_NONE;
 	BPFIF_LOCK(bp);
@@ -1839,12 +1870,22 @@
 		if (slen != 0) {
 			d->bd_fcount++;
 			if (gottime < bpf_ts_quality(d->bd_tstamp))
+			{
 				gottime = bpf_gettime(&bt, d->bd_tstamp, NULL);
+#ifdef FFCLOCK
+				ffcounter = read_ffcounter();
+#endif
+			}
 #ifdef MAC
 			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
 #endif
+#ifdef FFCLOCK
+				catchpacket(d, pkt, pktlen, slen,
+				    bpf_append_bytes, &bt, &ffcounter);
+#else
 				catchpacket(d, pkt, pktlen, slen,
 				    bpf_append_bytes, &bt);
+#endif	/* FFCLOCK */
 		}
 		BPFD_UNLOCK(d);
 	}
@@ -1868,6 +1909,9 @@
 #endif
 	u_int pktlen, slen;
 	int gottime;
+#ifdef FFCLOCK
+	ffcounter_t ffcounter;
+#endif
 
 	/* Skip outgoing duplicate packets. */
 	if ((m->m_flags & M_PROMISC) != 0 && m->m_pkthdr.rcvif == NULL) {
@@ -1895,12 +1939,23 @@
 		if (slen != 0) {
 			d->bd_fcount++;
 			if (gottime < bpf_ts_quality(d->bd_tstamp))
+			{
 				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+
+#ifdef FFCLOCK
+				ffcounter = read_ffcounter();
+#endif
+			}
 #ifdef MAC
 			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
 #endif
+#ifdef FFCLOCK
+				catchpacket(d, (u_char *)m, pktlen, slen,
+				    bpf_append_mbuf, &bt, &ffcounter);
+#else
 				catchpacket(d, (u_char *)m, pktlen, slen,
 				    bpf_append_mbuf, &bt);
+#endif 	/* FFCLOCK */
 		}
 		BPFD_UNLOCK(d);
 	}
@@ -1919,6 +1974,9 @@
 	struct bpf_d *d;
 	u_int pktlen, slen;
 	int gottime;
+#ifdef FFCLOCK
+	ffcounter_t ffcounter;
+#endif 	/* FFCLOCK */
 
 	/* Skip outgoing duplicate packets. */
 	if ((m->m_flags & M_PROMISC) != 0 && m->m_pkthdr.rcvif == NULL) {
@@ -1948,12 +2006,22 @@
 		if (slen != 0) {
 			d->bd_fcount++;
 			if (gottime < bpf_ts_quality(d->bd_tstamp))
+			{
 				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+#ifdef FFCLOCK
+				ffcounter = read_ffcounter();
+#endif 	/* FFCLOCK */
+			}
 #ifdef MAC
 			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
 #endif
+#ifdef FFCLOCK
+				catchpacket(d, (u_char *)m, pktlen, slen,
+				    bpf_append_mbuf, &bt, &ffcounter);
+#else
 				catchpacket(d, (u_char *)&mb, pktlen, slen,
 				    bpf_append_mbuf, &bt);
+#endif
 		}
 		BPFD_UNLOCK(d);
 	}
@@ -1995,6 +2063,7 @@
 	return (hdrlen - d->bd_bif->bif_hdrlen);
 }
 
+
 static void
 bpf_bintime2ts(struct bintime *bt, struct bpf_ts *ts, int tstype)
 {
@@ -2025,6 +2094,8 @@
 	}
 }
 
+
+
 /*
  * Move the packet data from interface memory (pkt) into the
  * store buffer.  "cpfn" is the routine called to do the actual data
@@ -2032,10 +2103,16 @@
  * bpf_append_mbuf is passed in to copy mbuf chains.  In the latter case,
  * pkt is really an mbuf.
  */
+#ifdef FFCLOCK
 static void
 catchpacket(struct bpf_d *d, u_char *pkt, u_int pktlen, u_int snaplen,
     void (*cpfn)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+    struct bintime *bt, ffcounter_t *ffcounter)
+#else
+catchpacket(struct bpf_d *d, u_char *pkt, u_int pktlen, u_int snaplen,
+    void (*cpfn)(struct bpf_d *, caddr_t, u_int, void *, u_int),
     struct bintime *bt)
+#endif
 {
 	struct bpf_xhdr hdr;
 #ifndef BURN_BRIDGES
@@ -2049,6 +2126,11 @@
 	int do_timestamp;
 	int tstype;
 
+// XXX FFCLOCK DEBUG XXX
+//	struct bpf_if *bp;
+//	bp = d->bd_bif;
+// XXX FFCLOCK DEBUG XXX	
+
 	BPFD_LOCK_ASSERT(d);
 
 	/*
@@ -2118,17 +2200,33 @@
 	if (tstype == BPF_T_NONE || BPF_T_FORMAT(tstype) == BPF_T_MICROTIME) {
 		struct bpf_ts ts;
 		if (do_timestamp)
+		{
+#ifdef FFCLOCK
+			/* If asked, use the RADclock to generate the bintime timestamp */
+			if ( (tstype & BPF_T_FFCLOCK) == BPF_T_FFCLOCK )
+				ffcounter2bintime(ffcounter, bt);
+#endif	/* FFCLOCK */
 			bpf_bintime2ts(bt, &ts, tstype);
+		}
 #ifdef COMPAT_FREEBSD32
 		if (d->bd_compat32) {
 			bzero(&hdr32_old, sizeof(hdr32_old));
 			if (do_timestamp) {
+#ifdef FFCLOCK
+				hdr32_old.ffcounter_stamp = *ffcounter;
+#endif
 				hdr32_old.bh_tstamp.tv_sec = ts.bt_sec;
 				hdr32_old.bh_tstamp.tv_usec = ts.bt_frac;
 			}
 			hdr32_old.bh_datalen = pktlen;
 			hdr32_old.bh_hdrlen = hdrlen;
 			hdr32_old.bh_caplen = caplen;
+
+// XXX FFCLOCK DEBUG XXX
+//if_printf(bp->bif_ifp, "radcatch: hdr32_old with hdrlen= %d, ffcounter= %llu\n",
+//	   	hdrlen, (long long unsigned) *ffcounter);
+// XXX FFCLOCK DEBUG XXX
+
 			bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr32_old,
 			    sizeof(hdr32_old));
 			goto copy;
@@ -2136,12 +2234,21 @@
 #endif
 		bzero(&hdr_old, sizeof(hdr_old));
 		if (do_timestamp) {
+#ifdef FFCLOCK
+			hdr_old.ffcounter_stamp = *ffcounter;
+#endif
 			hdr_old.bh_tstamp.tv_sec = ts.bt_sec;
 			hdr_old.bh_tstamp.tv_usec = ts.bt_frac;
 		}
 		hdr_old.bh_datalen = pktlen;
 		hdr_old.bh_hdrlen = hdrlen;
 		hdr_old.bh_caplen = caplen;
+
+// XXX FFCLOCK DEBUG XXX
+//if_printf(bp->bif_ifp, "radcatch: hdr_old with hdrlen= %d, ffcounter= %llu\n",
+//	   	hdrlen, (long long unsigned) *ffcounter);
+// XXX FFCLOCK DEBUG XXX
+
 		bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr_old,
 		    sizeof(hdr_old));
 		goto copy;
@@ -2154,10 +2261,23 @@
 	 */
 	bzero(&hdr, sizeof(hdr));
 	if (do_timestamp)
+	{
+#ifdef FFCLOCK
+		hdr.ffcounter_stamp = *ffcounter;
+		if ( (tstype & BPF_T_FFCLOCK) == BPF_T_FFCLOCK )
+			ffcounter2bintime(ffcounter, bt);
+#endif	/* FFCLOCK */
 		bpf_bintime2ts(bt, &hdr.bh_tstamp, tstype);
+	}
 	hdr.bh_datalen = pktlen;
 	hdr.bh_hdrlen = hdrlen;
 	hdr.bh_caplen = caplen;
+
+// XXX FFCLOCK DEBUG XXX
+//if_printf(bp->bif_ifp, "radcatch: xhdr with hdrlen= %d, ffcounter= %llu\n",
+//	   	hdrlen, (long long unsigned) *ffcounter);
+// XXX FFCLOCK DEBUG XXX
+
 	bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr, sizeof(hdr));
 
 	/*
diff -aur --unidirectional-new-file sys/net/bpf.h FreeBSD-CURRENT/net/bpf.h
--- sys/net/bpf.h	2010-12-09 15:14:44.000000000 +1100
+++ FreeBSD-CURRENT/net/bpf.h	2010-12-09 15:22:45.000000000 +1100
@@ -37,9 +37,13 @@
  * $FreeBSD: src/sys/net/bpf.h,v 1.56 2010/10/29 18:41:09 rpaulo Exp $
  */
 
+
+#include "opt_ffclock.h" 
+
 #ifndef _NET_BPF_H_
 #define _NET_BPF_H_
 
+
 /* BSD style release date */
 #define	BPF_RELEASE 199606
 
@@ -169,7 +173,12 @@
 #define	BPF_T_FAST		0x0100
 #define	BPF_T_MONOTONIC		0x0200
 #define	BPF_T_MONOTONIC_FAST	(BPF_T_FAST | BPF_T_MONOTONIC)
+#ifdef FFCLOCK
+#define	BPF_T_FFCLOCK		0x0400
+#define	BPF_T_FLAG_MASK		0x0700
+#else
 #define	BPF_T_FLAG_MASK		0x0300
+#endif
 #define	BPF_T_FORMAT(t)		((t) & BPF_T_FORMAT_MASK)
 #define	BPF_T_FLAG(t)		((t) & BPF_T_FLAG_MASK)
 #define	BPF_T_VALID(t)						\
@@ -185,6 +194,11 @@
 #define	BPF_T_MICROTIME_MONOTONIC_FAST	(BPF_T_MICROTIME | BPF_T_MONOTONIC_FAST)
 #define	BPF_T_NANOTIME_MONOTONIC_FAST	(BPF_T_NANOTIME | BPF_T_MONOTONIC_FAST)
 #define	BPF_T_BINTIME_MONOTONIC_FAST	(BPF_T_BINTIME | BPF_T_MONOTONIC_FAST)
+#ifdef FFCLOCK
+#define BPF_T_MICROTIME_FFCLOCK		(BPF_T_MICROTIME | BPF_T_FFCLOCK)
+#define BPF_T_NANOTIME_FFCLOCK		(BPF_T_NANOTIME | BPF_T_FFCLOCK)
+#define BPF_T_BINTIME_FFCLOCK		(BPF_T_BINTIME | BPF_T_FFCLOCK)
+#endif
 
 /*
  * Structure prepended to each packet.
@@ -193,21 +207,47 @@
 	bpf_int64	bt_sec;		/* seconds */
 	bpf_u_int64	bt_frac;	/* fraction */
 };
+
+#ifdef FFCLOCK
 struct bpf_xhdr {
 	struct bpf_ts	bh_tstamp;	/* time stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
 	bpf_u_int32	bh_datalen;	/* original length of packet */
 	u_short		bh_hdrlen;	/* length of bpf header (this struct
 					   plus alignment padding) */
+	u_short		padding;		/* padding to align the fields */
+	ffcounter_t	ffcounter_stamp;	/* feed-forward counter timestamp */
 };
+#else
+struct bpf_xhdr {
+	struct bpf_ts	bh_tstamp;	/* time stamp */
+	bpf_u_int32	bh_caplen;	/* length of captured portion */
+	bpf_u_int32	bh_datalen;	/* original length of packet */
+	u_short		bh_hdrlen;	/* length of bpf header (this struct
+					   plus alignment padding) */
+};
+#endif
+
 /* Obsolete */
+#ifdef FFCLOCK
 struct bpf_hdr {
 	struct timeval	bh_tstamp;	/* time stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
 	bpf_u_int32	bh_datalen;	/* original length of packet */
 	u_short		bh_hdrlen;	/* length of bpf header (this struct
 					   plus alignment padding) */
+	u_short		padding;		/* padding to align the fields */
+	ffcounter_t	ffcounter_stamp;	/* feed-forward counter timestamp */
 };
+#else
+struct bpf_hdr {
+	struct timeval	bh_tstamp;	/* time stamp */
+	bpf_u_int32	bh_caplen;	/* length of captured portion */
+	bpf_u_int32	bh_datalen;	/* original length of packet */
+	u_short		bh_hdrlen;	/* length of bpf header (this struct
+					   plus alignment padding) */
+};
+#endif
 #ifdef _KERNEL
 #define	MTAG_BPF		0x627066
 #define	MTAG_BPF_TIMESTAMP	0
diff -aur --unidirectional-new-file sys/sys/time.h FreeBSD-CURRENT/sys/time.h
--- sys/sys/time.h	2010-12-09 15:14:47.000000000 +1100
+++ FreeBSD-CURRENT/sys/time.h	2010-12-09 15:22:46.000000000 +1100
@@ -324,6 +324,49 @@
 void	getnanotime(struct timespec *tsp);
 void	getmicrotime(struct timeval *tvp);
 
+/* FFCLOCK specific */
+typedef uint64_t ffcounter_t;
+
+/* Feed-Forward Clock synchronisation structure */
+
+struct ffclock_data
+{
+	/* phat as an int shifted phat_shift to the left */
+	uint64_t phat_int;
+	/* Record of last time update from synchronization algorithm as an int */
+	uint64_t time_int;
+	/* The counter value to convert in seconds */
+	ffcounter_t ffcounter;
+	/* the shift amount for phat_int */
+	uint8_t phat_shift;
+	/* the shift amount for time_int */
+	uint8_t time_shift;
+	/* Warn if stamp is over this many bits */
+	uint8_t countdiff_maxbits;
+};
+
+struct ffclock_estimate
+{
+	volatile uint8_t gen;
+	struct ffclock_data cdata;
+};
+
+/* Current estimate and old one, no locking on the timestamping side */
+struct feedforward_clock
+{
+	volatile uint8_t updated;
+	struct ffclock_estimate *cest;
+	struct ffclock_estimate *ocest;
+	struct ffclock_estimate *ucest;
+};
+
+
+
+ffcounter_t read_ffcounter(void);
+void ffcounter2bintime(ffcounter_t *ffcounter, struct bintime *bt);
+/* FFCLOCK */
+
+
 /* Other functions */
 int	itimerdecr(struct itimerval *itp, int usec);
 int	itimerfix(struct timeval *tv);
diff -aur --unidirectional-new-file sys/sys/timepps.h FreeBSD-CURRENT/sys/timepps.h
--- sys/sys/timepps.h	2010-12-09 15:14:47.000000000 +1100
+++ FreeBSD-CURRENT/sys/timepps.h	2010-12-09 15:22:46.000000000 +1100
@@ -15,6 +15,8 @@
 #ifndef _SYS_TIMEPPS_H_
 #define _SYS_TIMEPPS_H_
 
+#include "opt_ffclock.h"
+
 #include <sys/ioccom.h>
 #include <sys/time.h>
 
@@ -43,12 +45,35 @@
 	int		current_mode;		/* current mode bits */
 } pps_info_t;
 
+
+#ifdef FFCLOCK
+typedef union pps_ffcounteru {
+	ffcounter_t ffcounter;
+} pps_ffcounteru_t;
+
+typedef struct {
+	pps_seq_t	assert_sequence;	/* assert event seq # */
+	pps_seq_t	clear_sequence;		/* clear event seq # */
+	pps_timeu_t	assert_tu;
+	pps_timeu_t	clear_tu;
+	int		current_mode;		/* current mode bits */
+	pps_ffcounteru_t  assert_vcu;
+	pps_ffcounteru_t  clear_vcu;
+} ffclock_pps_info_t;
+#endif	/* FFCLOCK */
+
+
 #define assert_timestamp        assert_tu.tspec
 #define clear_timestamp         clear_tu.tspec
 
 #define assert_timestamp_ntpfp  assert_tu.ntpfp
 #define clear_timestamp_ntpfp   clear_tu.ntpfp
 
+#ifdef FFCLOCK
+#define assert_ffcounter	assert_vcu.ffcounter
+#define clear_ffcounter		clear_vcu.ffcounter
+#endif 	/* FFCLOCK */
+
 typedef struct {
 	int api_version;			/* API version # */
 	int mode;				/* mode bits */
@@ -89,6 +114,14 @@
 	struct timespec	timeout;
 };
 
+#ifdef FFCLOCK
+struct ffclock_pps_fetch_args {
+	int tsformat;
+	ffclock_pps_info_t	pps_info_buf;
+	struct timespec	timeout;
+};
+#endif	/* FFCLOCK */
+
 struct pps_kcbind_args {
 	int kernel_consumer;
 	int edge;
@@ -102,6 +135,9 @@
 #define PPS_IOC_GETCAP		_IOR('1', 5, int)
 #define PPS_IOC_FETCH		_IOWR('1', 6, struct pps_fetch_args)
 #define PPS_IOC_KCBIND		_IOW('1', 7, struct pps_kcbind_args)
+#ifdef FFCLOCK
+#define FFCLOCK_PPS_IOC_FETCH		_IOWR('1', 8, struct ffclock_pps_fetch_args)
+#endif 	/* FFCLOCK */
 
 #ifdef _KERNEL
 
@@ -114,6 +150,9 @@
 	/* State information. */
 	pps_params_t	ppsparam;
 	pps_info_t	ppsinfo;
+#ifdef FFCLOCK
+	ffclock_pps_info_t	ffclock_ppsinfo;
+#endif 	/* FFCLOCK */
 	int		kcmode;
 	int		ppscap;
 	struct timecounter *ppstc;
@@ -183,6 +222,26 @@
 	return (error);
 }
 
+#ifdef FFCLOCK
+static __inline int
+ffclock_pps_fetch(pps_handle_t handle, const int tsformat,
+	ffclock_pps_info_t *ppsinfobuf, const struct timespec *timeout)
+{
+	int error;
+	struct ffclock_pps_fetch_args arg;
+
+	arg.tsformat = tsformat;
+	if (timeout == NULL) {
+		arg.timeout.tv_sec = -1;
+		arg.timeout.tv_nsec = -1;
+	} else
+		arg.timeout = *timeout;
+	error = ioctl(handle, FFCLOCK_PPS_IOC_FETCH, &arg);
+	*ppsinfobuf = arg.pps_info_buf;
+	return (error);
+}
+#endif 	/* FFCLOCK */
+
 static __inline int
 time_pps_kcbind(pps_handle_t handle, const int kernel_consumer,
 	const int edge, const int tsformat)
diff -aur --unidirectional-new-file sys/sys/timetc.h FreeBSD-CURRENT/sys/timetc.h
--- sys/sys/timetc.h	2010-12-09 15:14:47.000000000 +1100
+++ FreeBSD-CURRENT/sys/timetc.h	2010-12-09 15:22:46.000000000 +1100
@@ -16,6 +16,8 @@
 #error "no user-serviceable parts inside"
 #endif
 
+#include "opt_ffclock.h"
+
 /*-
  * `struct timecounter' is the interface between the hardware which implements
  * a timecounter and the MI code which uses this to keep track of time.
@@ -62,6 +64,14 @@
 		/* Pointer to the timecounter's private parts. */
 	struct timecounter	*tc_next;
 		/* Pointer to the next timecounter. */
+#ifdef FFCLOCK
+	uint64_t (*tc_get_timecount_64) (struct timecounter *);
+		/*
+		 * This function reads the counter and return a 64 bit unsigned int.
+		 * It is used for the passthrough mode, required by feed-forward
+		 * clocks in a virtual system (eg. Xen)
+		 */
+#endif 
 };
 
 extern struct timecounter *timecounter;
