Support for the RADclock and cumulative virtual timecounter
Freebsd Kernel patch: FreeBSD-CURRENT
Julien Ridoux
julien@synclab.org

diff -aur --unidirectional-new-file sys/amd64/amd64/tsc.c FreeBSD-CURRENT/amd64/amd64/tsc.c
--- sys/amd64/amd64/tsc.c	2010-11-30 21:40:29.000000000 +1100
+++ FreeBSD-CURRENT/amd64/amd64/tsc.c	2010-11-30 21:41:40.000000000 +1100
@@ -69,6 +69,18 @@
 static	unsigned tsc_get_timecount(struct timecounter *tc);
 static void tsc_levels_changed(void *arg, int unit);
 
+#ifdef RADCLOCK
+static uint64_t tsc_get_timecount_64(struct timecounter *tc);
+static struct timecounter tsc_timecounter = {
+	.tc_get_timecount = tsc_get_timecount,
+	.tc_poll_pps = 0,
+	.tc_counter_mask = ~0u,
+	.tc_frequency = 0,
+	.tc_name = "TSC",
+	.tc_quality = 800,
+	.tc_get_timecount_64 = &tsc_get_timecount_64
+};
+#else
 static struct timecounter tsc_timecounter = {
 	tsc_get_timecount,	/* get_timecount */
 	0,			/* no poll_pps */
@@ -77,6 +89,7 @@
 	"TSC",			/* name */
 	800,			/* quality (adjusted in code) */
 };
+#endif
 
 void
 init_TSC(void)
@@ -229,3 +242,11 @@
 {
 	return (rdtsc());
 }
+
+#ifdef RADCLOCK
+static uint64_t
+tsc_get_timecount_64(struct timecounter *tc)
+{
+	return (rdtsc());
+}
+#endif
diff -aur --unidirectional-new-file sys/amd64/conf/RADCLOCK.amd64 FreeBSD-CURRENT/amd64/conf/RADCLOCK.amd64
--- sys/amd64/conf/RADCLOCK.amd64	1970-01-01 10:00:00.000000000 +1000
+++ FreeBSD-CURRENT/amd64/conf/RADCLOCK.amd64	2010-11-30 21:41:40.000000000 +1100
@@ -0,0 +1,334 @@
+#
+# GENERIC -- Generic kernel configuration file for FreeBSD/amd64
+#
+# For more information on this file, please read the config(5) manual page,
+# and/or the handbook section on Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files.
+# If you are in doubt as to the purpose or necessity of a line, check first
+# in NOTES.
+#
+# $FreeBSD: src/sys/amd64/conf/GENERIC,v 1.549 2010/09/24 09:04:16 davidxu Exp $
+
+cpu		HAMMER
+ident	RADCLOCK
+
+makeoptions	DEBUG=-g		# Build kernel with gdb(1) debug symbols
+
+options 	SCHED_ULE		# ULE scheduler
+options 	PREEMPTION		# Enable kernel thread preemption
+options 	INET			# InterNETworking
+options 	INET6			# IPv6 communications protocols
+options 	SCTP			# Stream Control Transmission Protocol
+options 	FFS			# Berkeley Fast Filesystem
+options 	SOFTUPDATES		# Enable FFS soft updates support
+options 	UFS_ACL			# Support for access control lists
+options 	UFS_DIRHASH		# Improve performance on big directories
+options 	UFS_GJOURNAL		# Enable gjournal-based UFS journaling
+options 	MD_ROOT			# MD is a potential root device
+options 	NFSCLIENT		# Network Filesystem Client
+options 	NFSSERVER		# Network Filesystem Server
+options 	NFSLOCKD		# Network Lock Manager
+options 	NFS_ROOT		# NFS usable as /, requires NFSCLIENT
+options 	MSDOSFS			# MSDOS Filesystem
+options 	CD9660			# ISO 9660 Filesystem
+options 	PROCFS			# Process filesystem (requires PSEUDOFS)
+options 	PSEUDOFS		# Pseudo-filesystem framework
+options 	GEOM_PART_GPT		# GUID Partition Tables.
+options 	GEOM_LABEL		# Provides labelization
+options 	COMPAT_FREEBSD32	# Compatible with i386 binaries
+options 	COMPAT_FREEBSD4		# Compatible with FreeBSD4
+options 	COMPAT_FREEBSD5		# Compatible with FreeBSD5
+options 	COMPAT_FREEBSD6		# Compatible with FreeBSD6
+options 	COMPAT_FREEBSD7		# Compatible with FreeBSD7
+options 	SCSI_DELAY=5000		# Delay (in ms) before probing SCSI
+options 	KTRACE			# ktrace(1) support
+options 	STACK			# stack(9) support
+options 	SYSVSHM			# SYSV-style shared memory
+options 	SYSVMSG			# SYSV-style message queues
+options 	SYSVSEM			# SYSV-style semaphores
+options 	_KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
+options 	PRINTF_BUFR_SIZE=128	# Prevent printf output being interspersed.
+options 	KBD_INSTALL_CDEV	# install a CDEV entry in /dev
+options 	HWPMC_HOOKS		# Necessary kernel hooks for hwpmc(4)
+options 	AUDIT			# Security event auditing
+options 	MAC			# TrustedBSD MAC Framework
+options 	FLOWTABLE		# per-cpu routing cache
+#options 	KDTRACE_FRAME		# Ensure frames are compiled in
+#options 	KDTRACE_HOOKS		# Kernel DTrace hooks
+options 	INCLUDE_CONFIG_FILE     # Include this file in kernel
+
+# Debugging for use in -current
+options 	KDB			# Enable kernel debugger support.
+options 	DDB			# Support DDB.
+options 	GDB			# Support remote GDB.
+options 	DEADLKRES		# Enable the deadlock resolver
+options 	INVARIANTS		# Enable calls of extra sanity checking
+options 	INVARIANT_SUPPORT	# Extra sanity checks of internal structures, required by INVARIANTS
+options 	WITNESS			# Enable checks to detect deadlocks and cycles
+options 	WITNESS_SKIPSPIN	# Don't run witness on spinlocks for speed
+options 	MALLOC_DEBUG_MAXZONES=8	# Separate malloc(9) zones
+
+# Make an SMP-capable kernel by default
+options 	SMP			# Symmetric MultiProcessor Kernel
+
+# CPU frequency control
+device		cpufreq
+
+# Bus support.
+device		acpi
+device		pci
+
+# Floppy drives
+device		fdc
+
+# ATA and ATAPI devices
+device		ata
+device		atadisk		# ATA disk drives
+device		ataraid		# ATA RAID drives
+device		atapicd		# ATAPI CDROM drives
+device		atapifd		# ATAPI floppy drives
+device		atapist		# ATAPI tape drives
+options 	ATA_STATIC_ID	# Static device numbering
+
+# SCSI Controllers
+device		ahc		# AHA2940 and onboard AIC7xxx devices
+options 	AHC_REG_PRETTY_PRINT	# Print register bitfields in debug
+					# output.  Adds ~128k to driver.
+device		ahd		# AHA39320/29320 and onboard AIC79xx devices
+options 	AHD_REG_PRETTY_PRINT	# Print register bitfields in debug
+					# output.  Adds ~215k to driver.
+device		amd		# AMD 53C974 (Tekram DC-390(T))
+device		hptiop		# Highpoint RocketRaid 3xxx series
+device		isp		# Qlogic family
+#device		ispfw		# Firmware for QLogic HBAs- normally a module
+device		mpt		# LSI-Logic MPT-Fusion
+device		mps		# LSI-Logic MPT-Fusion 2
+#device		ncr		# NCR/Symbios Logic
+device		sym		# NCR/Symbios Logic (newer chipsets + those of `ncr')
+device		trm		# Tekram DC395U/UW/F DC315U adapters
+
+device		adv		# Advansys SCSI adapters
+device		adw		# Advansys wide SCSI adapters
+device		aic		# Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
+device		bt		# Buslogic/Mylex MultiMaster SCSI adapters
+
+# SCSI peripherals
+device		scbus		# SCSI bus (required for SCSI)
+device		ch		# SCSI media changers
+device		da		# Direct Access (disks)
+device		sa		# Sequential Access (tape etc)
+device		cd		# CD
+device		pass		# Passthrough device (direct SCSI access)
+device		ses		# SCSI Environmental Services (and SAF-TE)
+
+# RAID controllers interfaced to the SCSI subsystem
+device		amr		# AMI MegaRAID
+device		arcmsr		# Areca SATA II RAID
+#XXX it is not 64-bit clean, -scottl
+#device		asr		# DPT SmartRAID V, VI and Adaptec SCSI RAID
+device		ciss		# Compaq Smart RAID 5*
+device		dpt		# DPT Smartcache III, IV - See NOTES for options
+device		hptmv		# Highpoint RocketRAID 182x
+device		hptrr		# Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
+device		iir		# Intel Integrated RAID
+device		ips		# IBM (Adaptec) ServeRAID
+device		mly		# Mylex AcceleRAID/eXtremeRAID
+device		twa		# 3ware 9000 series PATA/SATA RAID
+
+# RAID controllers
+device		aac		# Adaptec FSA RAID
+device		aacp		# SCSI passthrough for aac (requires CAM)
+device		ida		# Compaq Smart RAID
+device		mfi		# LSI MegaRAID SAS
+device		mlx		# Mylex DAC960 family
+#XXX pointer/int warnings
+#device		pst		# Promise Supertrak SX6000
+device		twe		# 3ware ATA RAID
+
+# atkbdc0 controls both the keyboard and the PS/2 mouse
+device		atkbdc		# AT keyboard controller
+device		atkbd		# AT keyboard
+device		psm		# PS/2 mouse
+
+device		kbdmux		# keyboard multiplexer
+
+device		vga		# VGA video card driver
+
+device		splash		# Splash screen and screen saver support
+
+# syscons is the default console driver, resembling an SCO console
+device		sc
+
+device		agp		# support several AGP chipsets
+
+# PCCARD (PCMCIA) support
+# PCMCIA and cardbus bridge support
+device		cbb		# cardbus (yenta) bridge
+device		pccard		# PC Card (16-bit) bus
+device		cardbus		# CardBus (32-bit) bus
+
+# Serial (COM) ports
+device		uart		# Generic UART driver
+
+# Parallel port
+device		ppc
+device		ppbus		# Parallel port bus (required)
+device		lpt		# Printer
+device		plip		# TCP/IP over parallel
+device		ppi		# Parallel port interface device
+#device		vpo		# Requires scbus and da
+
+# If you've got a "dumb" serial or parallel PCI card that is
+# supported by the puc(4) glue driver, uncomment the following
+# line to enable it (connects to sio, uart and/or ppc drivers):
+#device		puc
+
+# PCI Ethernet NICs.
+device		de		# DEC/Intel DC21x4x (``Tulip'')
+device		em		# Intel PRO/1000 Gigabit Ethernet Family
+device		igb		# Intel PRO/1000 PCIE Server Gigabit Family
+device		ixgbe		# Intel PRO/10GbE PCIE Ethernet Family
+device		le		# AMD Am7900 LANCE and Am79C9xx PCnet
+device		ti		# Alteon Networks Tigon I/II gigabit Ethernet
+device		txp		# 3Com 3cR990 (``Typhoon'')
+device		vx		# 3Com 3c590, 3c595 (``Vortex'')
+
+# PCI Ethernet NICs that use the common MII bus controller code.
+# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
+device		miibus		# MII bus support
+device		ae		# Attansic/Atheros L2 FastEthernet
+device		age		# Attansic/Atheros L1 Gigabit Ethernet
+device		alc		# Atheros AR8131/AR8132 Ethernet
+device		ale		# Atheros AR8121/AR8113/AR8114 Ethernet
+device		bce		# Broadcom BCM5706/BCM5708 Gigabit Ethernet
+device		bfe		# Broadcom BCM440x 10/100 Ethernet
+device		bge		# Broadcom BCM570xx Gigabit Ethernet
+device		dc		# DEC/Intel 21143 and various workalikes
+device		et		# Agere ET1310 10/100/Gigabit Ethernet
+device		fxp		# Intel EtherExpress PRO/100B (82557, 82558)
+device		jme		# JMicron JMC250 Gigabit/JMC260 Fast Ethernet
+device		lge		# Level 1 LXT1001 gigabit Ethernet
+device		msk		# Marvell/SysKonnect Yukon II Gigabit Ethernet
+device		nfe		# nVidia nForce MCP on-board Ethernet
+device		nge		# NatSemi DP83820 gigabit Ethernet
+#device		nve		# nVidia nForce MCP on-board Ethernet Networking
+device		pcn		# AMD Am79C97x PCI 10/100 (precedence over 'le')
+device		re		# RealTek 8139C+/8169/8169S/8110S
+device		rl		# RealTek 8129/8139
+device		sf		# Adaptec AIC-6915 (``Starfire'')
+device		sge		# Silicon Integrated Systems SiS190/191
+device		sis		# Silicon Integrated Systems SiS 900/SiS 7016
+device		sk		# SysKonnect SK-984x & SK-982x gigabit Ethernet
+device		ste		# Sundance ST201 (D-Link DFE-550TX)
+device		stge		# Sundance/Tamarack TC9021 gigabit Ethernet
+device		tl		# Texas Instruments ThunderLAN
+device		tx		# SMC EtherPower II (83c170 ``EPIC'')
+device		vge		# VIA VT612x gigabit Ethernet
+device		vr		# VIA Rhine, Rhine II
+device		wb		# Winbond W89C840F
+device		xl		# 3Com 3c90x (``Boomerang'', ``Cyclone'')
+
+# ISA Ethernet NICs.  pccard NICs included.
+device		cs		# Crystal Semiconductor CS89x0 NIC
+# 'device ed' requires 'device miibus'
+device		ed		# NE[12]000, SMC Ultra, 3c503, DS8390 cards
+device		ex		# Intel EtherExpress Pro/10 and Pro/10+
+device		ep		# Etherlink III based cards
+device		fe		# Fujitsu MB8696x based cards
+device		sn		# SMC's 9000 series of Ethernet chips
+device		xe		# Xircom pccard Ethernet
+
+# Wireless NIC cards
+device		wlan		# 802.11 support
+options 	IEEE80211_DEBUG	# enable debug msgs
+options 	IEEE80211_AMPDU_AGE # age frames in AMPDU reorder q's
+options 	IEEE80211_SUPPORT_MESH	# enable 802.11s draft support
+device		wlan_wep	# 802.11 WEP support
+device		wlan_ccmp	# 802.11 CCMP support
+device		wlan_tkip	# 802.11 TKIP support
+device		wlan_amrr	# AMRR transmit rate control algorithm
+device		an		# Aironet 4500/4800 802.11 wireless NICs.
+device		ath		# Atheros pci/cardbus NIC's
+device		ath_hal		# pci/cardbus chip support
+options 	AH_SUPPORT_AR5416	# enable AR5416 tx/rx descriptors
+device		ath_rate_sample	# SampleRate tx rate control for ath
+device		ral		# Ralink Technology RT2500 wireless NICs.
+device		wi		# WaveLAN/Intersil/Symbol 802.11 wireless NICs.
+
+# Pseudo devices.
+device		loop		# Network loopback
+device		random		# Entropy device
+device		ether		# Ethernet support
+device		vlan		# 802.1Q VLAN support
+device		tun		# Packet tunnel.
+device		pty		# BSD-style compatibility pseudo ttys
+device		md		# Memory "disks"
+device		gif		# IPv6 and IPv4 tunneling
+device		faith		# IPv6-to-IPv4 relaying (translation)
+device		firmware	# firmware assist module
+
+# The `bpf' device enables the Berkeley Packet Filter.
+# Be aware of the administrative consequences of enabling this!
+# Note that 'bpf' is required for DHCP.
+device		bpf		# Berkeley packet filter
+
+# USB support
+options 	USB_DEBUG	# enable debug msgs
+device		uhci		# UHCI PCI->USB interface
+device		ohci		# OHCI PCI->USB interface
+device		ehci		# EHCI PCI->USB interface (USB 2.0)
+device		usb		# USB Bus (required)
+#device		udbp		# USB Double Bulk Pipe devices
+device		uhid		# "Human Interface Devices"
+device		ukbd		# Keyboard
+device		ulpt		# Printer
+device		umass		# Disks/Mass storage - Requires scbus and da
+device		ums		# Mouse
+device		urio		# Diamond Rio 500 MP3 player
+# USB Serial devices
+device		u3g		# USB-based 3G modems (Option, Huawei, Sierra)
+device		uark		# Technologies ARK3116 based serial adapters
+device		ubsa		# Belkin F5U103 and compatible serial adapters
+device		uftdi		# For FTDI usb serial adapters
+device		uipaq		# Some WinCE based devices
+device		uplcom		# Prolific PL-2303 serial adapters
+device		uslcom		# SI Labs CP2101/CP2102 serial adapters
+device		uvisor		# Visor and Palm devices
+device		uvscom		# USB serial support for DDI pocket's PHS
+# USB Ethernet, requires miibus
+device		aue		# ADMtek USB Ethernet
+device		axe		# ASIX Electronics USB Ethernet
+device		cdce		# Generic USB over Ethernet
+device		cue		# CATC USB Ethernet
+device		kue		# Kawasaki LSI USB Ethernet
+device		rue		# RealTek RTL8150 USB Ethernet
+device		udav		# Davicom DM9601E USB
+# USB Wireless
+device		rum		# Ralink Technology RT2501USB wireless NICs
+device		uath		# Atheros AR5523 wireless NICs
+device		ural		# Ralink Technology RT2500USB wireless NICs
+device		zyd		# ZyDAS zb1211/zb1211b wireless NICs
+
+# FireWire support
+device		firewire	# FireWire bus code
+device		sbp		# SCSI over FireWire (Requires scbus and da)
+device		fwe		# Ethernet over FireWire (non-standard!)
+device		fwip		# IP over FireWire (RFC 2734,3146)
+device		dcons		# Dumb console driver
+device		dcons_crom	# Configuration ROM for dcons
+
+# enable RADclock support
+options     RADCLOCK
+
+#enable PPS management in Kernel
+#options     PPS_SYNC
+
diff -aur --unidirectional-new-file sys/conf/options.amd64 FreeBSD-CURRENT/conf/options.amd64
--- sys/conf/options.amd64	2010-11-30 21:40:29.000000000 +1100
+++ FreeBSD-CURRENT/conf/options.amd64	2010-11-30 21:41:40.000000000 +1100
@@ -64,3 +64,7 @@
 BPF_JITTER		opt_bpf.h
 
 XENHVM			opt_global.h
+
+# RADclock support 
+RADCLOCK		opt_radclock.h
+
diff -aur --unidirectional-new-file sys/conf/options.i386 FreeBSD-CURRENT/conf/options.i386
--- sys/conf/options.i386	2010-11-30 21:40:29.000000000 +1100
+++ FreeBSD-CURRENT/conf/options.i386	2010-11-30 21:41:40.000000000 +1100
@@ -118,3 +118,7 @@
 
 NATIVE			opt_global.h
 XEN			opt_global.h
+
+# RADclock support 
+RADCLOCK		opt_radclock.h
+
diff -aur --unidirectional-new-file sys/dev/e1000/if_em.c FreeBSD-CURRENT/dev/e1000/if_em.c
--- sys/dev/e1000/if_em.c	2010-11-30 21:40:32.000000000 +1100
+++ FreeBSD-CURRENT/dev/e1000/if_em.c	2010-11-30 21:41:40.000000000 +1100
@@ -251,7 +251,10 @@
 static void	em_register_vlan(void *, struct ifnet *, u16);
 static void	em_unregister_vlan(void *, struct ifnet *, u16);
 static void	em_setup_vlan_hw_support(struct adapter *);
-static int	em_xmit(struct tx_ring *, struct mbuf **);
+
+// jrid
+//static int	em_xmit(struct tx_ring *, struct mbuf **);
+static int	em_xmit(struct tx_ring *, struct mbuf **, struct ifnet *);
 static int	em_dma_malloc(struct adapter *, bus_size_t,
 		    struct em_dma_alloc *, int);
 static void	em_dma_free(struct adapter *, struct em_dma_alloc *);
@@ -846,14 +849,17 @@
 
 	/* Process the queue */
 	while (next != NULL) {
-		if ((err = em_xmit(txr, &next)) != 0) {
+// jrid
+//		if ((err = em_xmit(txr, &next)) != 0) {
+		if ((err = em_xmit(txr, &next, ifp)) != 0) {
                         if (next != NULL)
                                 err = drbr_enqueue(ifp, txr->br, next);
                         break;
 		}
 		enq++;
 		drbr_stats_update(ifp, next->m_pkthdr.len, next->m_flags);
-		ETHER_BPF_MTAP(ifp, next);
+// jrid
+//		ETHER_BPF_MTAP(ifp, next);
 		if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0)
                         break;
 		if (txr->tx_avail < EM_MAX_SCATTER) {
@@ -942,7 +948,10 @@
 		 *  Encapsulation can modify our pointer, and or make it
 		 *  NULL on failure.  In that event, we can't requeue.
 		 */
-		if (em_xmit(txr, &m_head)) {
+// jrid
+// To be able to call BPF_MTAP from em_xmit
+//		if (em_xmit(txr, &m_head)) {
+		if (em_xmit(txr, &m_head, ifp)) {
 			if (m_head == NULL)
 				break;
 			ifp->if_drv_flags |= IFF_DRV_OACTIVE;
@@ -951,7 +960,11 @@
 		}
 
 		/* Send a copy of the frame to the BPF listener */
-		ETHER_BPF_MTAP(ifp, m_head);
+// jrid
+// This call after em_xmit() does not preserve causality
+// If called before em_xmit() (which can fail) takes the risk to send 2 copies of the
+// same packet. Need to move it into em_xmit()
+//		ETHER_BPF_MTAP(ifp, m_head);
 
 		/* Set timeout in case hardware has problems transmitting. */
 		txr->watchdog_time = ticks;
@@ -1743,8 +1756,11 @@
  *  return 0 on success, positive on failure
  **********************************************************************/
 
+// jrid
+//static int
+//em_xmit(struct tx_ring *txr, struct mbuf **m_headp)
 static int
-em_xmit(struct tx_ring *txr, struct mbuf **m_headp)
+em_xmit(struct tx_ring *txr, struct mbuf **m_headp, struct ifnet *ifp)
 {
 	struct adapter		*adapter = txr->adapter;
 	bus_dma_segment_t	segs[EM_MAX_SCATTER];
@@ -2034,6 +2050,9 @@
 	/* Update the watchdog time early and often */
 	txr->watchdog_time = ticks;
 
+// jrid
+// This cannot fail
+		ETHER_BPF_MTAP(ifp, m_head);
 	/*
 	 * Advance the Transmit Descriptor Tail (TDT), this tells the E1000
 	 * that this frame is available to transmit.
@@ -4071,7 +4090,10 @@
 	 * Set the interrupt throttling rate. Value is calculated
 	 * as DEFAULT_ITR = 1/(MAX_INTS_PER_SEC * 256ns)
 	 */
-	E1000_WRITE_REG(hw, E1000_ITR, DEFAULT_ITR);
+// jrid
+// Disable any type of interrupt throttling
+//	E1000_WRITE_REG(hw, E1000_ITR, DEFAULT_ITR);
+	E1000_WRITE_REG(hw, E1000_ITR, 0);
 
 	/*
 	** When using MSIX interrupts we need to throttle
diff -aur --unidirectional-new-file sys/i386/conf/RADCLOCK.i386 FreeBSD-CURRENT/i386/conf/RADCLOCK.i386
--- sys/i386/conf/RADCLOCK.i386	1970-01-01 10:00:00.000000000 +1000
+++ FreeBSD-CURRENT/i386/conf/RADCLOCK.i386	2010-11-30 21:41:40.000000000 +1100
@@ -0,0 +1,345 @@
+#
+# GENERIC -- Generic kernel configuration file for FreeBSD/i386
+#
+# For more information on this file, please read the config(5) manual page,
+# and/or the handbook section on Kernel Configuration Files:
+#
+#    http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
+#
+# The handbook is also available locally in /usr/share/doc/handbook
+# if you've installed the doc distribution, otherwise always see the
+# FreeBSD World Wide Web server (http://www.FreeBSD.org/) for the
+# latest information.
+#
+# An exhaustive list of options and more detailed explanations of the
+# device lines is also present in the ../../conf/NOTES and NOTES files.
+# If you are in doubt as to the purpose or necessity of a line, check first
+# in NOTES.
+#
+# $FreeBSD: src/sys/i386/conf/GENERIC,v 1.535 2010/09/24 09:04:16 davidxu Exp $
+
+cpu		I486_CPU
+cpu		I586_CPU
+cpu		I686_CPU
+ident	RADCLOCK
+
+makeoptions	DEBUG=-g		# Build kernel with gdb(1) debug symbols
+
+options 	SCHED_ULE		# ULE scheduler
+options 	PREEMPTION		# Enable kernel thread preemption
+options 	INET			# InterNETworking
+options 	INET6			# IPv6 communications protocols
+options 	SCTP			# Stream Control Transmission Protocol
+options 	FFS			# Berkeley Fast Filesystem
+options 	SOFTUPDATES		# Enable FFS soft updates support
+options 	UFS_ACL			# Support for access control lists
+options 	UFS_DIRHASH		# Improve performance on big directories
+options 	UFS_GJOURNAL		# Enable gjournal-based UFS journaling
+options 	MD_ROOT			# MD is a potential root device
+options 	NFSCLIENT		# Network Filesystem Client
+options 	NFSSERVER		# Network Filesystem Server
+options 	NFSLOCKD		# Network Lock Manager
+options 	NFS_ROOT		# NFS usable as /, requires NFSCLIENT
+options 	MSDOSFS			# MSDOS Filesystem
+options 	CD9660			# ISO 9660 Filesystem
+options 	PROCFS			# Process filesystem (requires PSEUDOFS)
+options 	PSEUDOFS		# Pseudo-filesystem framework
+options 	GEOM_PART_GPT		# GUID Partition Tables.
+options 	GEOM_LABEL		# Provides labelization
+options 	COMPAT_FREEBSD4		# Compatible with FreeBSD4
+options 	COMPAT_FREEBSD5		# Compatible with FreeBSD5
+options 	COMPAT_FREEBSD6		# Compatible with FreeBSD6
+options 	COMPAT_FREEBSD7		# Compatible with FreeBSD7
+options 	SCSI_DELAY=5000		# Delay (in ms) before probing SCSI
+options 	KTRACE			# ktrace(1) support
+options 	STACK			# stack(9) support
+options 	SYSVSHM			# SYSV-style shared memory
+options 	SYSVMSG			# SYSV-style message queues
+options 	SYSVSEM			# SYSV-style semaphores
+options 	_KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
+options 	PRINTF_BUFR_SIZE=128	# Prevent printf output being interspersed.
+options 	KBD_INSTALL_CDEV	# install a CDEV entry in /dev
+options 	HWPMC_HOOKS		# Necessary kernel hooks for hwpmc(4)
+options 	AUDIT			# Security event auditing
+options 	MAC			# TrustedBSD MAC Framework
+options 	FLOWTABLE		# per-cpu routing cache
+#options 	KDTRACE_HOOKS		# Kernel DTrace hooks
+options 	INCLUDE_CONFIG_FILE     # Include this file in kernel
+
+# Debugging for use in -current
+options 	KDB			# Enable kernel debugger support.
+options 	DDB			# Support DDB.
+options 	GDB			# Support remote GDB.
+options 	DEADLKRES		# Enable the deadlock resolver
+options 	INVARIANTS		# Enable calls of extra sanity checking
+options 	INVARIANT_SUPPORT	# Extra sanity checks of internal structures, required by INVARIANTS
+options 	WITNESS			# Enable checks to detect deadlocks and cycles
+options 	WITNESS_SKIPSPIN	# Don't run witness on spinlocks for speed
+options 	MALLOC_DEBUG_MAXZONES=8	# Separate malloc(9) zones
+
+# To make an SMP kernel, the next two lines are needed
+options 	SMP			# Symmetric MultiProcessor Kernel
+device		apic			# I/O APIC
+
+# CPU frequency control
+device		cpufreq
+
+# Bus support.
+device		acpi
+device		eisa
+device		pci
+
+# Floppy drives
+device		fdc
+
+# ATA and ATAPI devices
+device		ata
+device		atadisk		# ATA disk drives
+device		ataraid		# ATA RAID drives
+device		atapicd		# ATAPI CDROM drives
+device		atapifd		# ATAPI floppy drives
+device		atapist		# ATAPI tape drives
+options 	ATA_STATIC_ID	# Static device numbering
+
+# SCSI Controllers
+device		ahb		# EISA AHA1742 family
+device		ahc		# AHA2940 and onboard AIC7xxx devices
+options 	AHC_REG_PRETTY_PRINT	# Print register bitfields in debug
+					# output.  Adds ~128k to driver.
+device		ahd		# AHA39320/29320 and onboard AIC79xx devices
+options 	AHD_REG_PRETTY_PRINT	# Print register bitfields in debug
+					# output.  Adds ~215k to driver.
+device		amd		# AMD 53C974 (Tekram DC-390(T))
+device		hptiop		# Highpoint RocketRaid 3xxx series
+device		isp		# Qlogic family
+#device		ispfw		# Firmware for QLogic HBAs- normally a module
+device		mpt		# LSI-Logic MPT-Fusion
+#device		ncr		# NCR/Symbios Logic
+device		sym		# NCR/Symbios Logic (newer chipsets + those of `ncr')
+device		trm		# Tekram DC395U/UW/F DC315U adapters
+
+device		adv		# Advansys SCSI adapters
+device		adw		# Advansys wide SCSI adapters
+device		aha		# Adaptec 154x SCSI adapters
+device		aic		# Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
+device		bt		# Buslogic/Mylex MultiMaster SCSI adapters
+
+device		ncv		# NCR 53C500
+device		nsp		# Workbit Ninja SCSI-3
+device		stg		# TMC 18C30/18C50
+
+# SCSI peripherals
+device		scbus		# SCSI bus (required for SCSI)
+device		ch		# SCSI media changers
+device		da		# Direct Access (disks)
+device		sa		# Sequential Access (tape etc)
+device		cd		# CD
+device		pass		# Passthrough device (direct SCSI access)
+device		ses		# SCSI Environmental Services (and SAF-TE)
+
+# RAID controllers interfaced to the SCSI subsystem
+device		amr		# AMI MegaRAID
+device		arcmsr		# Areca SATA II RAID
+device		asr		# DPT SmartRAID V, VI and Adaptec SCSI RAID
+device		ciss		# Compaq Smart RAID 5*
+device		dpt		# DPT Smartcache III, IV - See NOTES for options
+device		hptmv		# Highpoint RocketRAID 182x
+device		hptrr		# Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
+device		iir		# Intel Integrated RAID
+device		ips		# IBM (Adaptec) ServeRAID
+device		mly		# Mylex AcceleRAID/eXtremeRAID
+device		twa		# 3ware 9000 series PATA/SATA RAID
+
+# RAID controllers
+device		aac		# Adaptec FSA RAID
+device		aacp		# SCSI passthrough for aac (requires CAM)
+device		ida		# Compaq Smart RAID
+device		mfi		# LSI MegaRAID SAS
+device		mlx		# Mylex DAC960 family
+device		pst		# Promise Supertrak SX6000
+device		twe		# 3ware ATA RAID
+
+# atkbdc0 controls both the keyboard and the PS/2 mouse
+device		atkbdc		# AT keyboard controller
+device		atkbd		# AT keyboard
+device		psm		# PS/2 mouse
+
+device		kbdmux		# keyboard multiplexer
+
+device		vga		# VGA video card driver
+
+device		splash		# Splash screen and screen saver support
+
+# syscons is the default console driver, resembling an SCO console
+device		sc
+
+device		agp		# support several AGP chipsets
+
+# Power management support (see NOTES for more options)
+#device		apm
+# Add suspend/resume support for the i8254.
+device		pmtimer
+
+# PCCARD (PCMCIA) support
+# PCMCIA and cardbus bridge support
+device		cbb		# cardbus (yenta) bridge
+device		pccard		# PC Card (16-bit) bus
+device		cardbus		# CardBus (32-bit) bus
+
+# Serial (COM) ports
+device		uart		# Generic UART driver
+
+# Parallel port
+device		ppc
+device		ppbus		# Parallel port bus (required)
+device		lpt		# Printer
+device		plip		# TCP/IP over parallel
+device		ppi		# Parallel port interface device
+#device		vpo		# Requires scbus and da
+
+# If you've got a "dumb" serial or parallel PCI card that is
+# supported by the puc(4) glue driver, uncomment the following
+# line to enable it (connects to sio, uart and/or ppc drivers):
+#device		puc
+
+# PCI Ethernet NICs.
+device		de		# DEC/Intel DC21x4x (``Tulip'')
+device		em		# Intel PRO/1000 Gigabit Ethernet Family
+device		igb		# Intel PRO/1000 PCIE Server Gigabit Family
+device		ixgb		# Intel PRO/10GbE Ethernet Card
+device		le		# AMD Am7900 LANCE and Am79C9xx PCnet
+device		ti		# Alteon Networks Tigon I/II gigabit Ethernet
+device		txp		# 3Com 3cR990 (``Typhoon'')
+device		vx		# 3Com 3c590, 3c595 (``Vortex'')
+
+# PCI Ethernet NICs that use the common MII bus controller code.
+# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
+device		miibus		# MII bus support
+device		ae		# Attansic/Atheros L2 FastEthernet
+device		age		# Attansic/Atheros L1 Gigabit Ethernet
+device		alc		# Atheros AR8131/AR8132 Ethernet
+device		ale		# Atheros AR8121/AR8113/AR8114 Ethernet
+device		bce		# Broadcom BCM5706/BCM5708 Gigabit Ethernet
+device		bfe		# Broadcom BCM440x 10/100 Ethernet
+device		bge		# Broadcom BCM570xx Gigabit Ethernet
+device		dc		# DEC/Intel 21143 and various workalikes
+device		et		# Agere ET1310 10/100/Gigabit Ethernet
+device		fxp		# Intel EtherExpress PRO/100B (82557, 82558)
+device		jme		# JMicron JMC250 Gigabit/JMC260 Fast Ethernet
+device		lge		# Level 1 LXT1001 gigabit Ethernet
+device		msk		# Marvell/SysKonnect Yukon II Gigabit Ethernet
+device		nfe		# nVidia nForce MCP on-board Ethernet
+device		nge		# NatSemi DP83820 gigabit Ethernet
+#device		nve		# nVidia nForce MCP on-board Ethernet Networking
+device		pcn		# AMD Am79C97x PCI 10/100 (precedence over 'le')
+device		re		# RealTek 8139C+/8169/8169S/8110S
+device		rl		# RealTek 8129/8139
+device		sf		# Adaptec AIC-6915 (``Starfire'')
+device		sge		# Silicon Integrated Systems SiS190/191
+device		sis		# Silicon Integrated Systems SiS 900/SiS 7016
+device		sk		# SysKonnect SK-984x & SK-982x gigabit Ethernet
+device		ste		# Sundance ST201 (D-Link DFE-550TX)
+device		stge		# Sundance/Tamarack TC9021 gigabit Ethernet
+device		tl		# Texas Instruments ThunderLAN
+device		tx		# SMC EtherPower II (83c170 ``EPIC'')
+device		vge		# VIA VT612x gigabit Ethernet
+device		vr		# VIA Rhine, Rhine II
+device		wb		# Winbond W89C840F
+device		xl		# 3Com 3c90x (``Boomerang'', ``Cyclone'')
+
+# ISA Ethernet NICs.  pccard NICs included.
+device		cs		# Crystal Semiconductor CS89x0 NIC
+# 'device ed' requires 'device miibus'
+device		ed		# NE[12]000, SMC Ultra, 3c503, DS8390 cards
+device		ex		# Intel EtherExpress Pro/10 and Pro/10+
+device		ep		# Etherlink III based cards
+device		fe		# Fujitsu MB8696x based cards
+device		ie		# EtherExpress 8/16, 3C507, StarLAN 10 etc.
+device		sn		# SMC's 9000 series of Ethernet chips
+device		xe		# Xircom pccard Ethernet
+
+# Wireless NIC cards
+device		wlan		# 802.11 support
+options 	IEEE80211_DEBUG	# enable debug msgs
+options 	IEEE80211_AMPDU_AGE # age frames in AMPDU reorder q's
+options 	IEEE80211_SUPPORT_MESH	# enable 802.11s draft support
+device		wlan_wep	# 802.11 WEP support
+device		wlan_ccmp	# 802.11 CCMP support
+device		wlan_tkip	# 802.11 TKIP support
+device		wlan_amrr	# AMRR transmit rate control algorithm
+device		an		# Aironet 4500/4800 802.11 wireless NICs.
+device		ath		# Atheros pci/cardbus NIC's
+device		ath_hal		# pci/cardbus chip support
+options 	AH_SUPPORT_AR5416	# enable AR5416 tx/rx descriptors
+device		ath_rate_sample	# SampleRate tx rate control for ath
+device		ral		# Ralink Technology RT2500 wireless NICs.
+device		wi		# WaveLAN/Intersil/Symbol 802.11 wireless NICs.
+#device		wl		# Older non 802.11 Wavelan wireless NIC.
+
+# Pseudo devices.
+device		loop		# Network loopback
+device		random		# Entropy device
+device		ether		# Ethernet support
+device		vlan		# 802.1Q VLAN support
+device		tun		# Packet tunnel.
+device		pty		# BSD-style compatibility pseudo ttys
+device		md		# Memory "disks"
+device		gif		# IPv6 and IPv4 tunneling
+device		faith		# IPv6-to-IPv4 relaying (translation)
+device		firmware	# firmware assist module
+
+# The `bpf' device enables the Berkeley Packet Filter.
+# Be aware of the administrative consequences of enabling this!
+# Note that 'bpf' is required for DHCP.
+device		bpf		# Berkeley packet filter
+
+# USB support
+options 	USB_DEBUG	# enable debug msgs
+device		uhci		# UHCI PCI->USB interface
+device		ohci		# OHCI PCI->USB interface
+device		ehci		# EHCI PCI->USB interface (USB 2.0)
+device		usb		# USB Bus (required)
+#device		udbp		# USB Double Bulk Pipe devices
+device		uhid		# "Human Interface Devices"
+device		ukbd		# Keyboard
+device		ulpt		# Printer
+device		umass		# Disks/Mass storage - Requires scbus and da
+device		ums		# Mouse
+device		urio		# Diamond Rio 500 MP3 player
+# USB Serial devices
+device		u3g		# USB-based 3G modems (Option, Huawei, Sierra)
+device		uark		# Technologies ARK3116 based serial adapters
+device		ubsa		# Belkin F5U103 and compatible serial adapters
+device		uftdi		# For FTDI usb serial adapters
+device		uipaq		# Some WinCE based devices
+device		uplcom		# Prolific PL-2303 serial adapters
+device		uslcom		# SI Labs CP2101/CP2102 serial adapters
+device		uvisor		# Visor and Palm devices
+device		uvscom		# USB serial support for DDI pocket's PHS
+# USB Ethernet, requires miibus
+device		aue		# ADMtek USB Ethernet
+device		axe		# ASIX Electronics USB Ethernet
+device		cdce		# Generic USB over Ethernet
+device		cue		# CATC USB Ethernet
+device		kue		# Kawasaki LSI USB Ethernet
+device		rue		# RealTek RTL8150 USB Ethernet
+device		udav		# Davicom DM9601E USB
+# USB Wireless
+device		rum		# Ralink Technology RT2501USB wireless NICs
+device		uath		# Atheros AR5523 wireless NICs
+device		ural		# Ralink Technology RT2500USB wireless NICs
+device		zyd		# ZyDAS zb1211/zb1211b wireless NICs
+
+# FireWire support
+device		firewire	# FireWire bus code
+device		sbp		# SCSI over FireWire (Requires scbus and da)
+device		fwe		# Ethernet over FireWire (non-standard!)
+device		fwip		# IP over FireWire (RFC 2734,3146)
+device		dcons		# Dumb console driver
+device		dcons_crom	# Configuration ROM for dcons
+
+# enable RADCLOCK support 
+options		RADCLOCK
+
+#enable PPS management in Kernel
+#options		PPS_SYNC
diff -aur --unidirectional-new-file sys/i386/i386/tsc.c FreeBSD-CURRENT/i386/i386/tsc.c
--- sys/i386/i386/tsc.c	2010-11-30 21:40:35.000000000 +1100
+++ FreeBSD-CURRENT/i386/i386/tsc.c	2010-11-30 21:41:40.000000000 +1100
@@ -70,6 +70,18 @@
 static	unsigned tsc_get_timecount(struct timecounter *tc);
 static void tsc_levels_changed(void *arg, int unit);
 
+#ifdef RADCLOCK
+static uint64_t tsc_get_timecount_64(struct timecounter *tc);
+static struct timecounter tsc_timecounter = {
+	.tc_get_timecount = tsc_get_timecount,
+	.tc_poll_pps = 0,
+	.tc_counter_mask = ~0u,
+	.tc_frequency = 0,
+	.tc_name = "TSC",
+	.tc_quality = 800,
+	.tc_get_timecount_64 = &tsc_get_timecount_64
+};
+#else
 static struct timecounter tsc_timecounter = {
 	tsc_get_timecount,	/* get_timecount */
 	0,			/* no poll_pps */
@@ -78,6 +90,7 @@
 	"TSC",			/* name */
 	800,			/* quality (adjusted in code) */
 };
+#endif
 
 void
 init_TSC(void)
@@ -257,3 +270,11 @@
 {
 	return (rdtsc());
 }
+
+#ifdef RADCLOCK
+static uint64_t
+tsc_get_timecount_64(struct timecounter *tc)
+{
+	return (rdtsc());
+}
+#endif
diff -aur --unidirectional-new-file sys/i386/xen/clock.c FreeBSD-CURRENT/i386/xen/clock.c
--- sys/i386/xen/clock.c	2010-11-30 21:40:35.000000000 +1100
+++ FreeBSD-CURRENT/i386/xen/clock.c	2010-11-30 21:41:40.000000000 +1100
@@ -292,6 +292,19 @@
 
 static	unsigned xen_get_timecount(struct timecounter *tc);
 
+#ifdef RADCLOCK
+static uint64_t xen_get_timecount_64(struct timecounter *tc);
+
+static struct timecounter xen_timecounter = {
+	.tc_get_timecount = xen_get_timecount,
+	.tc_poll_pps = 0,
+	.tc_counter_mask = ~0u,
+	.tc_frequency = 0,
+	.tc_name = "ixen",
+	.tc_quality = 0,
+	.tc_get_timecount_64 = &xen_get_timecount_64 
+};
+#else
 static struct timecounter xen_timecounter = {
 	xen_get_timecount,	/* get_timecount */
 	0,			/* no poll_pps */
@@ -300,6 +313,7 @@
 	"ixen",			/* name */
 	0			/* quality */
 };
+#endif
 
 static int
 clkintr(void *arg)
@@ -833,6 +847,21 @@
 
 }
 
+#ifdef RADCLOCK
+static uint64_t
+xen_get_timecount_64(struct timecounter *tc)
+{	
+	uint64_t clk;
+	struct shadow_time_info *shadow;
+	shadow = &per_cpu(shadow_time, smp_processor_id());
+
+	__get_time_values_from_xen();
+	clk = shadow->system_timestamp + get_nsec_offset(shadow);
+
+	return clk;
+}
+#endif
+
 /* Return system time offset by ticks */
 uint64_t
 get_system_time(int ticks)
diff -aur --unidirectional-new-file sys/kern/kern_tc.c FreeBSD-CURRENT/kern/kern_tc.c
--- sys/kern/kern_tc.c	2010-11-30 21:40:36.000000000 +1100
+++ FreeBSD-CURRENT/kern/kern_tc.c	2010-11-30 21:41:40.000000000 +1100
@@ -21,6 +21,99 @@
 #include <sys/timetc.h>
 #include <sys/timex.h>
 
+
+
+#ifdef RADCLOCK
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/malloc.h>
+/* Global data structure containing clock estimates */ 
+static struct feedfwd_clock ffclock;
+
+MALLOC_DECLARE(M_FFCLOCK);
+MALLOC_DEFINE(M_FFCLOCK, "FFCLOCK", "Feed-Forward Clock estimates");
+
+
+// TODO should pass first timecounter frequency estimate here to get something
+// consistent at startup
+static void
+initffclock(struct feedfwd_clock *ffclock)
+{
+	ffclock->generation = 0;
+	ffclock->estimate = (struct radclock_fixedpoint *) malloc(sizeof(struct radclock_fixedpoint), M_FFCLOCK, M_WAITOK | M_ZERO);
+	ffclock->estimate_old = (struct radclock_fixedpoint *) malloc(sizeof(struct radclock_fixedpoint), M_FFCLOCK, M_WAITOK | M_ZERO);
+	ffclock->tmp = NULL;
+}
+
+
+
+void
+radclock_vcount2bintime(vcounter_t *vcount, struct bintime *bt)
+{
+	vcounter_t countdiff;
+//	struct timeval tval;
+	uint64_t time_f;
+	uint64_t frac;
+	struct radclock_fixedpoint *clock_fp;
+	uint8_t gen;
+
+	/* Synchronization algorithm (userland) should update the fixed point data
+	 * often enough to make sure the timeval does not overflow. If no sync algo
+	 * updates the data, we loose precision, but in that case, nobody is tracking
+	 * the clock drift anyway ... so send warning and stop worrying.
+	 */
+
+	/* XXX: So far we are called from catchpacket() only, that ia called from
+	 * one of the *tap functions, each of them holding the BPFD_LOCK(bd) lock.
+	 * ioctl ops are conditioned by the same lock, ensuring the consistency of
+	 * the fixedpoint data. If we move away from the BPF code (and we should),
+	 * we should lock in here.
+	 */
+	do {
+		clock_fp = ffclock.estimate;
+		gen = ffclock.generation;
+
+		countdiff = *vcount - clock_fp->vcount;
+		if (countdiff & ~((1ll << (clock_fp->countdiff_maxbits +1)) -1))
+			printf("RADclock: warning stamp may overflow timeval at %llu!\n",
+					(long long unsigned) *vcount);
+
+		/* Add the counter delta in second to the recorded fixed point time */
+		time_f 	= clock_fp->time_int
+				  + ((clock_fp->phat_int * countdiff) >> (clock_fp->phat_shift - clock_fp->time_shift)) ;
+
+		bt->sec  = time_f >> clock_fp->time_shift;
+
+		// gives me headaches again
+		// frac * ( 2^64 - 2^time_shift) ... that should be the correct resolution
+		frac = time_f - ((uint64_t) bt->sec << clock_fp->time_shift);
+		bt->frac = frac * ((uint64_t) 1LL << (64 - clock_fp->time_shift));
+
+	} while (gen == 0 || gen != ffclock.generation);
+
+
+	
+//	tval.tv_sec = time_f >> clock_fp.time_shift;
+//
+//	frac = (time_f - ((uint64_t)tval.tv_sec << clock_fp.time_shift));
+//	tval.tv_usec = (frac * 1000000LL)  >> clock_fp.time_shift;
+//	/* tv.tv_usec truncates at the nano-second digit, so check for next digit rounding */
+//	if ( ((frac * 10000000LL) >> clock_fp.time_shift) >= (tval.tv_usec * 10LL + 5) )
+//	{
+//		tval.tv_usec++;
+//	}
+//
+//	/* Push the built timeval */
+//	*time = tval;
+	
+	/* XXX: If not called with BPFD_LOCK(bd), then should release the fixedpoint data
+	 * lock in here
+	 */
+}
+
+#endif /* RADCLOCK */
+
+
 /*
  * A large step happens on boot.  This constant detects such steps.
  * It is relatively small so that ntp_update_second gets called enough
@@ -53,6 +146,11 @@
 	int64_t			th_adjustment;
 	uint64_t		th_scale;
 	u_int	 		th_offset_count;
+
+#ifdef RADCLOCK
+	vcounter_t		vcounter_record;
+#endif
+
 	struct bintime		th_offset;
 	struct timeval		th_microtime;
 	struct timespec		th_nanotime;
@@ -61,6 +159,30 @@
 	struct timehands	*th_next;
 };
 
+#ifdef RADCLOCK
+static struct timehands th0;
+static struct timehands th9 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th0};
+static struct timehands th8 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th9};
+static struct timehands th7 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th8};
+static struct timehands th6 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th7};
+static struct timehands th5 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th6};
+static struct timehands th4 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th5};
+static struct timehands th3 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th4};
+static struct timehands th2 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th3};
+static struct timehands th1 = { NULL, 0, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th2};
+static struct timehands th0 = {
+	&dummy_timecounter,
+	0,
+	(uint64_t)-1 / 1000000,
+	0,
+	0,
+	{1, 0},
+	{0, 0},
+	{0, 0},
+	1,
+	&th1
+};
+#else
 static struct timehands th0;
 static struct timehands th9 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th0};
 static struct timehands th8 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th9};
@@ -82,6 +204,7 @@
 	1,
 	&th1
 };
+#endif	/* RADCLOCK */
 
 static struct timehands *volatile timehands = &th0;
 struct timecounter *timecounter = &dummy_timecounter;
@@ -163,6 +286,47 @@
  * the comment in <sys/time.h> for a description of these 12 functions.
  */
 
+#ifdef RADCLOCK
+static int sysctl_kern_timecounter_passthrough = 0;
+SYSCTL_INT(_kern_timecounter, OID_AUTO, passthrough, CTLFLAG_RW,
+	&sysctl_kern_timecounter_passthrough, 0,
+	"Select universal Feed-Forward timecounter for OS virtualization");
+
+
+static __inline uint64_t
+tc_get_timecount_fake64(struct timecounter *tc)
+{
+	u_int count;
+	count = tc->tc_get_timecount(tc);
+	return (uint64_t) count;
+}
+
+vcounter_t
+read_vcounter(void)
+{
+	struct timecounter *tc;
+	struct timehands *th;
+	u_int gen, delta;
+	vcounter_t vcount;
+
+	if ( sysctl_kern_timecounter_passthrough )
+	{
+		tc = timehands->th_counter;
+		return tc->tc_get_timecount_64(tc);
+	}
+	else {
+		do{
+			th = timehands;
+			gen = th->th_generation;
+			delta = tc_delta(th);
+			vcount = th->vcounter_record;
+		} while ( gen == 0 || gen != th->th_generation);
+
+		return(vcount + delta);
+	}
+}
+#endif	/* RADCLOCK */
+
 void
 binuptime(struct bintime *bt)
 {
@@ -325,7 +489,13 @@
 		    tc->tc_name, (uintmax_t)tc->tc_frequency,
 		    tc->tc_quality);
 	}
-
+#ifdef RADCLOCK
+	/* XXX this is a very ugly but good enough to cover my back */
+	if ( (strcmp(tc->tc_name, "TSC") != 0) && (strcmp(tc->tc_name, "ixen") != 0) )
+	{
+		tc->tc_get_timecount_64 = &tc_get_timecount_fake64;
+	}
+#endif
 	tc->tc_next = timecounters;
 	timecounters = tc;
 	/*
@@ -440,6 +610,11 @@
 		ncount = timecounter->tc_get_timecount(timecounter);
 	else
 		ncount = 0;
+
+#ifdef RADCLOCK
+	th->vcounter_record += delta;
+#endif
+
 	th->th_offset_count += delta;
 	th->th_offset_count &= th->th_counter->tc_counter_mask;
 	bintime_addx(&th->th_offset, th->th_scale * delta);
@@ -486,6 +661,9 @@
 		th->th_offset_count = ncount;
 		tc_min_ticktock_freq = max(1, timecounter->tc_frequency /
 		    (((uint64_t)timecounter->tc_counter_mask + 1) / 3));
+		#ifdef RADCLOCK
+		th->vcounter_record = 0;
+		#endif
 	}
 
 	/*-
@@ -594,6 +772,10 @@
 {
 	pps_params_t *app;
 	struct pps_fetch_args *fapi;
+#ifdef RADCLOCK
+	struct radclock_pps_fetch_args *radclock_fapi;
+#endif
+
 #ifdef PPS_SYNC
 	struct pps_kcbind_args *kapi;
 #endif
@@ -627,6 +809,19 @@
 		pps->ppsinfo.current_mode = pps->ppsparam.mode;
 		fapi->pps_info_buf = pps->ppsinfo;
 		return (0);
+
+#ifdef RADCLOCK
+	case RADCLOCK_PPS_IOC_FETCH:
+		radclock_fapi = (struct radclock_pps_fetch_args *)data;
+		if (radclock_fapi->tsformat && radclock_fapi->tsformat != PPS_TSFMT_TSPEC)
+			return (EINVAL);
+		if (radclock_fapi->timeout.tv_sec || radclock_fapi->timeout.tv_nsec)
+			return (EOPNOTSUPP);
+		pps->ppsinfo.current_mode = pps->ppsparam.mode;
+		radclock_fapi->pps_info_buf = pps->radclock_ppsinfo;
+		return (0);
+#endif 	/* RADCLOCK */
+
 	case PPS_IOC_KCBIND:
 #ifdef PPS_SYNC
 		kapi = (struct pps_kcbind_args *)data;
@@ -679,6 +874,12 @@
 	u_int tcount, *pcount;
 	int foff, fhard;
 	pps_seq_t *pseq;
+#ifdef RADCLOCK
+	struct timespec *radclock_tsp;
+	pps_seq_t *radclock_pseq;
+	vcounter_t *vcount;
+	vcounter_t vcounter_record;
+#endif
 
 	KASSERT(pps != NULL, ("NULL pps pointer in pps_event"));
 	/* If the timecounter was wound up underneath us, bail out. */
@@ -693,6 +894,11 @@
 		fhard = pps->kcmode & PPS_CAPTUREASSERT;
 		pcount = &pps->ppscount[0];
 		pseq = &pps->ppsinfo.assert_sequence;
+#ifdef RADCLOCK
+		vcount = &pps->radclock_ppsinfo.assert_vcount;
+		radclock_tsp = &pps->radclock_ppsinfo.assert_timestamp;
+		radclock_pseq = &pps->radclock_ppsinfo.assert_sequence;
+#endif
 	} else {
 		tsp = &pps->ppsinfo.clear_timestamp;
 		osp = &pps->ppsparam.clear_offset;
@@ -700,6 +906,11 @@
 		fhard = pps->kcmode & PPS_CAPTURECLEAR;
 		pcount = &pps->ppscount[1];
 		pseq = &pps->ppsinfo.clear_sequence;
+#ifdef RADCLOCK
+		vcount = &pps->radclock_ppsinfo.clear_vcount;
+		radclock_tsp = &pps->radclock_ppsinfo.clear_timestamp;
+		radclock_pseq = &pps->radclock_ppsinfo.clear_sequence;
+#endif
 	}
 
 	/*
@@ -716,6 +927,9 @@
 	/* Convert the count to a timespec. */
 	tcount = pps->capcount - pps->capth->th_offset_count;
 	tcount &= pps->capth->th_counter->tc_counter_mask;
+#ifdef RADCLOCK
+	vcounter_record = pps->capth->vcounter_record;
+#endif
 	bt = pps->capth->th_offset;
 	bintime_addx(&bt, pps->capth->th_scale * tcount);
 	bintime_add(&bt, &boottimebin);
@@ -728,6 +942,11 @@
 	*pcount = pps->capcount;
 	(*pseq)++;
 	*tsp = ts;
+#ifdef RADCLOCK
+	(*radclock_pseq)++;
+	*radclock_tsp = ts;
+	*vcount = (vcounter_record + tcount);
+#endif
 
 	if (foff) {
 		timespecadd(tsp, osp);
@@ -806,6 +1025,10 @@
 	(void)timecounter->tc_get_timecount(timecounter);
 	(void)timecounter->tc_get_timecount(timecounter);
 	tc_windup();
+
+#ifdef RADCLOCK
+	initffclock(&ffclock);
+#endif
 }
 
 SYSINIT(timecounter, SI_SUB_CLOCKS, SI_ORDER_SECOND, inittimecounter, NULL);
diff -aur --unidirectional-new-file sys/kern/radclock.c FreeBSD-CURRENT/kern/radclock.c
--- sys/kern/radclock.c	1970-01-01 10:00:00.000000000 +1000
+++ FreeBSD-CURRENT/kern/radclock.c	2010-11-30 21:41:40.000000000 +1100
@@ -0,0 +1,327 @@
+/*
+ * System calls to access the cumulative virtual timecounter
+ */
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/proc.h>
+#include <sys/module.h>
+#include <sys/sysent.h>
+#include <sys/kernel.h>
+#include <sys/systm.h>
+#include <sys/time.h>
+#include <sys/sysproto.h>
+#include <sys/bus.h>
+#include <sys/sysctl.h>
+
+
+extern struct feedfwd_clock ffclock;
+
+static struct mtx ffclock_mtx;	/* lock against concurrent updates of the ffclock estimates */
+
+/*
+ * Sysctl
+ */
+static int sysctl_version = 2;
+
+SYSCTL_NODE(_kern, OID_AUTO, ffclock, CTLFLAG_RW, 0, "Feed-Forward Clock Support");
+SYSCTL_INT(_kern_ffclock, OID_AUTO, version, CTLFLAG_RD, &sysctl_version, 0, "Version of Feed-Forward Clock Support");
+
+
+/*
+ * First system call is get_vcounter to retrieve the current value
+ * of the cumulative vritual counter from the timecounter interface
+ */
+
+struct get_vcounter_args {
+	vcounter_t *vcount;
+};
+
+static int
+get_vcounter(struct proc *td, void *syscall_args)
+{
+	vcounter_t vcount = 0;
+	int error = 0;
+	struct get_vcounter_args *uap;
+
+	uap = (struct get_vcounter_args *) syscall_args;
+	if ( uap->vcount == NULL )
+		return -1;
+	
+	vcount = read_vcounter();
+	error = copyout(&vcount, uap->vcount, sizeof(vcounter_t));
+	
+	if ( vcount == 0 ) 
+		error = -1;
+
+	return(error);
+}
+
+
+static struct sysent get_vcounter_sysent = {
+	1,
+	(sy_call_t *) get_vcounter,
+	AUE_NULL, 
+	NULL, 
+	0, 
+	0 
+};
+
+
+static int get_vcounter_offset = NO_SYSCALL;
+
+static int
+get_vcounter_load (struct module *module, int cmd, void *arg)
+{
+	int error = 0;
+	switch (cmd) {
+		case MOD_LOAD :
+			printf("get_vcounter syscall loaded at %d \n", get_vcounter_offset);
+		break;
+		case MOD_UNLOAD :
+			printf("get_vcounter syscall unloaded from %d\n", get_vcounter_offset);
+		break;
+		default :
+			error = EINVAL;
+		break;
+	}
+	return error;
+}
+
+/*
+ * XXX we used to call SYSCALL_MODULE to help us with declaring the modules.
+ * Starting with FreeBSD 8.1, the module name was prepended with "sys/" in the
+ * moduledata_t structure. To avoid yet another naming issues, we do
+ * SYSCALL_MODULE's work instead and overwrite this convention.
+ * See /usr/src/sys/sys/sysent.h for the details.
+ *
+ * Hopefully, this will disappear once we go mainstream
+ */
+//SYSCALL_MODULE(get_vcounter, &get_vcounter_offset, &get_vcounter_sysent, get_vcounter_load, NULL);
+
+static struct syscall_module_data get_vcounter_syscall_mod = {
+	get_vcounter_load,
+	NULL,
+	&get_vcounter_offset,
+	&get_vcounter_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t get_vcounter_mod = {
+	"get_vcounter",
+	syscall_module_handler,
+	&get_vcounter_syscall_mod
+};
+
+DECLARE_MODULE(get_vcounter, get_vcounter_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+
+
+
+/*
+ * Second system call is get_vcounter_latency to compute the latency of
+ * the timecounter interface from within the kernel
+ *
+ * XXX: of course this makes sense ONLY if we have a stable TSC
+ * (i.e. no SMP, no power management, no frequency jumps etc.) 
+ */
+
+struct get_vcounter_latency_args {
+	vcounter_t *vcount;
+	uint64_t *vcount_lat;
+	uint64_t *tsc_lat;
+};
+
+static int
+get_vcounter_latency(struct proc *td, void *syscall_args)
+{
+	uint64_t tsc1 = 0, tsc2 = 0, tsc3 = 0, vcount_lat = 0, tsc_lat = 0;
+	vcounter_t vcount;
+	int error = 0;
+	struct get_vcounter_latency_args *uap;
+
+	uap = (struct get_vcounter_latency_args *) syscall_args;
+
+	/* One for fun and warmup */
+	tsc1 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+	tsc1 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+	tsc2 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+	vcount = read_vcounter();
+	__asm __volatile("lfence" ::: "memory");
+	tsc3 = rdtsc();
+	__asm __volatile("lfence" ::: "memory");
+
+	tsc_lat = tsc2 - tsc1;
+	vcount_lat = tsc3 - tsc2;
+
+	error += copyout(&vcount, uap->vcount, sizeof(vcounter_t));
+	error += copyout(&vcount_lat, uap->vcount_lat, sizeof(uint64_t));
+	error += copyout(&tsc_lat, uap->tsc_lat, sizeof(uint64_t));
+
+	return(error);
+}
+
+
+static struct sysent get_vcounter_latency_sysent = {
+	3,
+	(sy_call_t *) get_vcounter_latency,
+	AUE_NULL, 
+	NULL, 
+	0, 
+	0 
+};
+
+
+static int get_vcounter_latency_offset = NO_SYSCALL;
+
+static int
+get_vcounter_latency_load (struct module *module, int cmd, void *arg)
+{
+	int error = 0;
+	switch (cmd) {
+		case MOD_LOAD :
+			printf("get_vcounter_latency syscall loaded at %d \n", get_vcounter_latency_offset);
+		break;
+		case MOD_UNLOAD :
+			printf("get_vcounter_latency syscall unloaded from %d\n", get_vcounter_latency_offset);
+		break;
+		default :
+			error = EINVAL;
+		break;
+	}
+	return error;
+}
+
+/* See comment above for use of SYSCALL_MODULE before 8.1 */
+//SYSCALL_MODULE(get_vcounter_latency, &get_vcounter_latency_offset, &get_vcounter_latency_sysent, get_vcounter_latency_load, NULL);
+
+static struct syscall_module_data get_vcounter_latency_syscall_mod = {
+	get_vcounter_latency_load,
+	NULL,
+	&get_vcounter_latency_offset,
+	&get_vcounter_latency_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t get_vcounter_latency_mod = {
+	"get_vcounter_latency",
+	syscall_module_handler,
+	&get_vcounter_latency_syscall_mod
+};
+
+DECLARE_MODULE(get_vcounter_latency, get_vcounter_latency_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+
+
+
+/*
+ * System call to push clock parameters to the kernel 
+ */
+
+struct set_ffclock_args {
+	struct radclock_fixedpoint *clock_fp;
+};
+
+
+/*
+ * Write down the clock estimates passed from userland. Hold ffclock_mtx to
+ * prevent several instances to update concurrently.
+ */
+static int
+set_ffclock(struct proc *td, void *syscall_args)
+{
+	int error = 0;
+	uint8_t gen;
+	struct set_ffclock_args *uap;
+
+	uap = (struct set_ffclock_args *) syscall_args;
+	if ( uap->clock_fp == NULL )
+		return -1;
+
+	mtx_lock(&ffclock_mtx);
+
+	gen = ffclock.generation;
+	error = copyin(uap->clock_fp, ffclock.estimate_old, sizeof(ffclock.estimate_old));
+
+	ffclock.tmp = ffclock.estimate;
+
+	if (++gen == 0)
+		gen = 1;
+	
+	ffclock.estimate = ffclock.estimate_old;
+	ffclock.generation = gen;
+	ffclock.estimate_old = ffclock.tmp;
+	ffclock.tmp = NULL;
+		
+	mtx_unlock(&ffclock_mtx);
+
+	return(error);
+}
+
+
+static struct sysent set_ffclock_sysent = {
+	1,
+	(sy_call_t *) set_ffclock,
+	AUE_NULL, 
+	NULL, 
+	0, 
+	0 
+};
+
+
+static int set_ffclock_offset = NO_SYSCALL;
+
+static int
+set_ffclock_load (struct module *module, int cmd, void *arg)
+{
+	int error = 0;
+	switch (cmd) {
+		case MOD_LOAD :
+			mtx_init(&ffclock_mtx, "ffclock lock", NULL, MTX_DEF);
+			printf("set_ffclock syscall loaded at %d \n", set_ffclock_offset);
+		break;
+		case MOD_UNLOAD :
+			mtx_destroy(&ffclock_mtx);
+			printf("set_ffclock syscall unloaded from %d\n", set_ffclock_offset);
+		break;
+		default :
+			error = EINVAL;
+		break;
+	}
+	return error;
+}
+
+/*
+ * XXX we used to call SYSCALL_MODULE to help us with declaring the modules.
+ * Starting with FreeBSD 8.1, the module name was prepended with "sys/" in the
+ * moduledata_t structure. To avoid yet another naming issues, we do
+ * SYSCALL_MODULE's work instead and overwrite this convention.
+ * See /usr/src/sys/sys/sysent.h for the details.
+ *
+ * Hopefully, this will disappear once we go mainstream
+ */
+//SYSCALL_MODULE(get_vcounter, &get_vcounter_offset, &get_vcounter_sysent, get_vcounter_load, NULL);
+
+static struct syscall_module_data set_ffclock_syscall_mod = {
+	set_ffclock_load,
+	NULL,
+	&set_ffclock_offset,
+	&set_ffclock_sysent,
+	{ 0, NULL, AUE_NULL}
+};
+
+static moduledata_t set_ffclock_mod = {
+	"set_ffclock",
+	syscall_module_handler,
+	&set_ffclock_syscall_mod
+};
+
+DECLARE_MODULE(set_ffclock, set_ffclock_mod, SI_SUB_SYSCALLS, SI_ORDER_MIDDLE);
+
+
+
diff -aur --unidirectional-new-file sys/modules/Makefile FreeBSD-CURRENT/modules/Makefile
--- sys/modules/Makefile	2010-11-30 21:40:38.000000000 +1100
+++ FreeBSD-CURRENT/modules/Makefile	2010-11-30 21:41:40.000000000 +1100
@@ -241,6 +241,7 @@
 	${_pst} \
 	pty  \
 	puc \
+	radclock \
 	ral \
 	ralfw \
 	${_random} \
diff -aur --unidirectional-new-file sys/modules/radclock/Makefile FreeBSD-CURRENT/modules/radclock/Makefile
--- sys/modules/radclock/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ FreeBSD-CURRENT/modules/radclock/Makefile	2010-11-30 21:41:40.000000000 +1100
@@ -0,0 +1,15 @@
+# This make file creates the .ko module for retrieving the vitual counter through syscall.
+
+.PATH: ${.CURDIR}/../../kern
+
+KMOD    =  radclock
+SRCS    =  radclock.c
+
+SRCS+=	opt_radclock.h
+
+.if !defined(KERNBUILDDIR)
+opt_radclock.h:
+	echo "#define RADCLOCK 1" > opt_radclock.h
+.endif
+
+.include <bsd.kmod.mk>
diff -aur --unidirectional-new-file sys/net/bpf.c FreeBSD-CURRENT/net/bpf.c
--- sys/net/bpf.c	2010-11-30 21:40:38.000000000 +1100
+++ FreeBSD-CURRENT/net/bpf.c	2010-11-30 21:41:40.000000000 +1100
@@ -90,8 +90,13 @@
 
 #define PRINET  26			/* interruptible */
 
+#ifdef RADCLOCK
+#define	SIZEOF_BPF_HDR(type)	\
+    (offsetof(type, vcount_stamp) + sizeof(((type *)0)->vcount_stamp))
+#else
 #define	SIZEOF_BPF_HDR(type)	\
     (offsetof(type, bh_hdrlen) + sizeof(((type *)0)->bh_hdrlen))
+#endif	/* RADCLOCK */
 
 #ifdef COMPAT_FREEBSD32
 #include <sys/mount.h>
@@ -111,6 +116,10 @@
 	uint32_t	bh_datalen;	/* original length of packet */
 	uint16_t	bh_hdrlen;	/* length of bpf header (this struct
 					   plus alignment padding) */
+#ifdef RADCLOCK
+	u_short     padding;        /* padding to align the fields */
+	vcounter_t  vcount_stamp;   /* raw virtual timecounter timestamp for this packet */      
+#endif
 };
 #endif
 
@@ -151,9 +160,15 @@
 static void	bpf_timed_out(void *);
 static __inline void
 		bpf_wakeup(struct bpf_d *);
+#ifdef RADCLOCK
+static void catchpacket(struct bpf_d *, u_char *, u_int, u_int,
+			void (*)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+			struct bintime *, vcounter_t *);
+#else
 static void	catchpacket(struct bpf_d *, u_char *, u_int, u_int,
 		    void (*)(struct bpf_d *, caddr_t, u_int, void *, u_int),
 		    struct bintime *);
+#endif
 static void	reset_d(struct bpf_d *);
 static int	 bpf_setf(struct bpf_d *, struct bpf_program *, u_long cmd);
 static int	bpf_getdltlist(struct bpf_d *, struct bpf_dltlist *);
@@ -172,6 +187,11 @@
     &bpf_zerocopy_enable, 0, "Enable new zero-copy BPF buffer sessions");
 SYSCTL_NODE(_net_bpf, OID_AUTO, stats, CTLFLAG_MPSAFE | CTLFLAG_RW,
     bpf_stats_sysctl, "bpf statistics portal");
+#ifdef RADCLOCK
+static int bpf_tstamp_ffclock = 0; 
+SYSCTL_INT(_net_bpf, OID_AUTO, bpf_tstamp_ffclock, CTLFLAG_RW,
+	&bpf_tstamp_ffclock, 0, "BPF default timestamps use Feed-Forward clock");
+#endif /* RADCLOCK */
 
 static	d_open_t	bpfopen;
 static	d_read_t	bpfread;
@@ -698,6 +718,14 @@
 	callout_init_mtx(&d->bd_callout, &d->bd_mtx, 0);
 	knlist_init_mtx(&d->bd_sel.si_note, &d->bd_mtx);
 
+#ifdef RADCLOCK
+	/* Timestamping mode for this device, default is use the system clock */
+	if (bpf_tstamp_ffclock)
+		d->bd_tstamp = d->bd_tstamp | BPF_T_FFCLOCK;
+	else
+		d->bd_tstamp = d->bd_tstamp & ~BPF_T_FFCLOCK;
+#endif /* RADCLOCK */
+
 	return (0);
 }
 
@@ -1510,6 +1538,24 @@
 	case BIOCROTZBUF:
 		error = bpf_ioctl_rotzbuf(td, d, (struct bpf_zbuf *)addr);
 		break;
+//#ifdef RADCLOCK
+//	/* Set RADclock timestamping mode for this device) */
+//	case BIOCSRADCLOCKTSMODE:
+//		{
+//			BPFD_LOCK(d);
+//			d->radclock_tsmode = *(int8_t *)addr;  
+//			BPFD_UNLOCK(d);
+//			break;
+//		}
+//	/* Get RADclock timestamping mode for this device) */
+//	case BIOCGRADCLOCKTSMODE:
+//		{
+//			BPFD_LOCK(d);
+//			*(int8_t *)addr = d->radclock_tsmode;
+//			BPFD_UNLOCK(d);
+//			break;
+//		}
+//#endif /* RADCLOCK */
 	}
 	CURVNET_RESTORE();
 	return (error);
@@ -1817,6 +1863,9 @@
 #endif
 	u_int slen;
 	int gottime;
+#ifdef RADCLOCK
+	vcounter_t vcount;
+#endif
 
 	gottime = BPF_TSTAMP_NONE;
 	BPFIF_LOCK(bp);
@@ -1839,12 +1888,22 @@
 		if (slen != 0) {
 			d->bd_fcount++;
 			if (gottime < bpf_ts_quality(d->bd_tstamp))
+			{
 				gottime = bpf_gettime(&bt, d->bd_tstamp, NULL);
+#ifdef RADCLOCK
+				vcount = read_vcounter();
+#endif
+			}
 #ifdef MAC
 			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
 #endif
+#ifdef RADCLOCK
+				catchpacket(d, pkt, pktlen, slen,
+				    bpf_append_bytes, &bt, &vcount);
+#else
 				catchpacket(d, pkt, pktlen, slen,
 				    bpf_append_bytes, &bt);
+#endif	/* RADCLOCK */
 		}
 		BPFD_UNLOCK(d);
 	}
@@ -1868,6 +1927,9 @@
 #endif
 	u_int pktlen, slen;
 	int gottime;
+#ifdef RADCLOCK
+	vcounter_t vcount;
+#endif
 
 	/* Skip outgoing duplicate packets. */
 	if ((m->m_flags & M_PROMISC) != 0 && m->m_pkthdr.rcvif == NULL) {
@@ -1895,12 +1957,23 @@
 		if (slen != 0) {
 			d->bd_fcount++;
 			if (gottime < bpf_ts_quality(d->bd_tstamp))
+			{
 				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+
+#ifdef RADCLOCK
+				vcount = read_vcounter();
+#endif
+			}
 #ifdef MAC
 			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
 #endif
+#ifdef RADCLOCK
+				catchpacket(d, (u_char *)m, pktlen, slen,
+				    bpf_append_mbuf, &bt, &vcount);
+#else
 				catchpacket(d, (u_char *)m, pktlen, slen,
 				    bpf_append_mbuf, &bt);
+#endif 	/* RADCLOCK */
 		}
 		BPFD_UNLOCK(d);
 	}
@@ -1919,6 +1992,9 @@
 	struct bpf_d *d;
 	u_int pktlen, slen;
 	int gottime;
+#ifdef RADCLOCK
+	vcounter_t vcount;
+#endif 	/* RADCLOCK */
 
 	/* Skip outgoing duplicate packets. */
 	if ((m->m_flags & M_PROMISC) != 0 && m->m_pkthdr.rcvif == NULL) {
@@ -1948,12 +2024,22 @@
 		if (slen != 0) {
 			d->bd_fcount++;
 			if (gottime < bpf_ts_quality(d->bd_tstamp))
+			{
 				gottime = bpf_gettime(&bt, d->bd_tstamp, m);
+#ifdef RADCLOCK
+				vcount = read_vcounter();
+#endif 	/* RADCLOCK */
+			}
 #ifdef MAC
 			if (mac_bpfdesc_check_receive(d, bp->bif_ifp) == 0)
 #endif
+#ifdef RADCLOCK
+				catchpacket(d, (u_char *)m, pktlen, slen,
+				    bpf_append_mbuf, &bt, &vcount);
+#else
 				catchpacket(d, (u_char *)&mb, pktlen, slen,
 				    bpf_append_mbuf, &bt);
+#endif
 		}
 		BPFD_UNLOCK(d);
 	}
@@ -1995,6 +2081,7 @@
 	return (hdrlen - d->bd_bif->bif_hdrlen);
 }
 
+
 static void
 bpf_bintime2ts(struct bintime *bt, struct bpf_ts *ts, int tstype)
 {
@@ -2025,6 +2112,8 @@
 	}
 }
 
+
+
 /*
  * Move the packet data from interface memory (pkt) into the
  * store buffer.  "cpfn" is the routine called to do the actual data
@@ -2032,10 +2121,16 @@
  * bpf_append_mbuf is passed in to copy mbuf chains.  In the latter case,
  * pkt is really an mbuf.
  */
+#ifdef RADCLOCK
 static void
 catchpacket(struct bpf_d *d, u_char *pkt, u_int pktlen, u_int snaplen,
     void (*cpfn)(struct bpf_d *, caddr_t, u_int, void *, u_int),
+    struct bintime *bt, vcounter_t *vcount)
+#else
+catchpacket(struct bpf_d *d, u_char *pkt, u_int pktlen, u_int snaplen,
+    void (*cpfn)(struct bpf_d *, caddr_t, u_int, void *, u_int),
     struct bintime *bt)
+#endif
 {
 	struct bpf_xhdr hdr;
 #ifndef BURN_BRIDGES
@@ -2049,6 +2144,11 @@
 	int do_timestamp;
 	int tstype;
 
+// XXX RADCLOCK DEBUG XXX	
+	struct bpf_if *bp;
+	bp = d->bd_bif;
+// XXX RADCLOCK DEBUG XXX	
+
 	BPFD_LOCK_ASSERT(d);
 
 	/*
@@ -2118,17 +2218,33 @@
 	if (tstype == BPF_T_NONE || BPF_T_FORMAT(tstype) == BPF_T_MICROTIME) {
 		struct bpf_ts ts;
 		if (do_timestamp)
+		{
+#ifdef RADCLOCK
+			/* If asked, use the RADclock to generate the bintime timestamp */
+			if ( (d->bd_tstamp & BPF_T_FFCLOCK) == BPF_T_FFCLOCK )
+				radclock_vcount2bintime(vcount, bt);
+#endif	/* RADCLOCK */
 			bpf_bintime2ts(bt, &ts, tstype);
+		}
 #ifdef COMPAT_FREEBSD32
 		if (d->bd_compat32) {
 			bzero(&hdr32_old, sizeof(hdr32_old));
 			if (do_timestamp) {
+#ifdef RADCLOCK
+				hdr32_old.vcount_stamp = *vcount;  // In all cases, store the vcount read previously
+#endif
 				hdr32_old.bh_tstamp.tv_sec = ts.bt_sec;
 				hdr32_old.bh_tstamp.tv_usec = ts.bt_frac;
 			}
 			hdr32_old.bh_datalen = pktlen;
 			hdr32_old.bh_hdrlen = hdrlen;
 			hdr32_old.bh_caplen = caplen;
+
+// XXX RADCLOCK DEBUG XXX
+if_printf(bp->bif_ifp, "radcatch: hdr32_old with hdrlen= %d, vcount= %llu\n",
+	   	hdrlen, (long long unsigned) *vcount);
+// XXX RADCLOCK DEBUG XXX
+
 			bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr32_old,
 			    sizeof(hdr32_old));
 			goto copy;
@@ -2136,12 +2252,21 @@
 #endif
 		bzero(&hdr_old, sizeof(hdr_old));
 		if (do_timestamp) {
+#ifdef RADCLOCK
+			hdr_old.vcount_stamp = *vcount;  // In all cases, store the vcount read previously
+#endif
 			hdr_old.bh_tstamp.tv_sec = ts.bt_sec;
 			hdr_old.bh_tstamp.tv_usec = ts.bt_frac;
 		}
 		hdr_old.bh_datalen = pktlen;
 		hdr_old.bh_hdrlen = hdrlen;
 		hdr_old.bh_caplen = caplen;
+
+// XXX RADCLOCK DEBUG XXX
+if_printf(bp->bif_ifp, "radcatch: hdr_old with hdrlen= %d, vcount= %llu\n",
+	   	hdrlen, (long long unsigned) *vcount);
+// XXX RADCLOCK DEBUG XXX
+
 		bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr_old,
 		    sizeof(hdr_old));
 		goto copy;
@@ -2154,10 +2279,23 @@
 	 */
 	bzero(&hdr, sizeof(hdr));
 	if (do_timestamp)
+	{
+#ifdef RADCLOCK
+		hdr.vcount_stamp = *vcount;  // In all cases, store the vcount read previously
+		if ( (d->bd_tstamp & BPF_T_FFCLOCK) == BPF_T_FFCLOCK )
+			radclock_vcount2bintime(vcount, bt);
+#endif	/* RADCLOCK */
 		bpf_bintime2ts(bt, &hdr.bh_tstamp, tstype);
+	}
 	hdr.bh_datalen = pktlen;
 	hdr.bh_hdrlen = hdrlen;
 	hdr.bh_caplen = caplen;
+
+// XXX RADCLOCK DEBUG XXX
+if_printf(bp->bif_ifp, "radcatch: xhdr with hdrlen= %d, vcount= %llu\n",
+	   	hdrlen, (long long unsigned) *vcount);
+// XXX RADCLOCK DEBUG XXX
+
 	bpf_append_bytes(d, d->bd_sbuf, curlen, &hdr, sizeof(hdr));
 
 	/*
diff -aur --unidirectional-new-file sys/net/bpf.h FreeBSD-CURRENT/net/bpf.h
--- sys/net/bpf.h	2010-11-30 21:40:38.000000000 +1100
+++ FreeBSD-CURRENT/net/bpf.h	2010-11-30 21:41:40.000000000 +1100
@@ -37,9 +37,13 @@
  * $FreeBSD: src/sys/net/bpf.h,v 1.56 2010/10/29 18:41:09 rpaulo Exp $
  */
 
+
+#include "opt_radclock.h" 
+
 #ifndef _NET_BPF_H_
 #define _NET_BPF_H_
 
+
 /* BSD style release date */
 #define	BPF_RELEASE 199606
 
@@ -152,6 +156,17 @@
 #define	BIOCGSEESENT	BIOCGDIRECTION
 #define	BIOCSSEESENT	BIOCSDIRECTION
 
+#ifdef RADCLOCK
+// TODO: merge with BPF_T_ symbols??
+/* RADclock timestamping modes */
+//#define RADCLOCK_TSMODE_SYSCLOCK		0x0001  /* return SW timeval (normal behavior) and raw vcounter */
+//#define RADCLOCK_TSMODE_RADCLOCK		0x0002  /* return timeval based on RADclock and raw vcounter */
+//#define RADCLOCK_TSMODE_FAIRCOMPARE 	0x0003  /* return SW timeval and raw vcounter read back to back */
+
+//#define BIOCSRADCLOCKTSMODE	_IOW('B',133, int8_t) /* Set timestamping mode for this device) */
+//#define BIOCGRADCLOCKTSMODE	_IOR('B',134, int8_t) /* Get timestamping  mode for this device */
+#endif /* RADCLOCK */
+
 /* Packet directions */
 enum bpf_direction {
 	BPF_D_IN,	/* See incoming packets */
@@ -169,7 +184,12 @@
 #define	BPF_T_FAST		0x0100
 #define	BPF_T_MONOTONIC		0x0200
 #define	BPF_T_MONOTONIC_FAST	(BPF_T_FAST | BPF_T_MONOTONIC)
+#ifdef RADCLOCK
+#define	BPF_T_FFCLOCK		0x0400
+#define	BPF_T_FLAG_MASK		0x0700
+#else
 #define	BPF_T_FLAG_MASK		0x0300
+#endif
 #define	BPF_T_FORMAT(t)		((t) & BPF_T_FORMAT_MASK)
 #define	BPF_T_FLAG(t)		((t) & BPF_T_FLAG_MASK)
 #define	BPF_T_VALID(t)						\
@@ -185,6 +205,11 @@
 #define	BPF_T_MICROTIME_MONOTONIC_FAST	(BPF_T_MICROTIME | BPF_T_MONOTONIC_FAST)
 #define	BPF_T_NANOTIME_MONOTONIC_FAST	(BPF_T_NANOTIME | BPF_T_MONOTONIC_FAST)
 #define	BPF_T_BINTIME_MONOTONIC_FAST	(BPF_T_BINTIME | BPF_T_MONOTONIC_FAST)
+#ifdef RADCLOCK
+#define BPF_T_MICROTIME_FFCLOCK		(BPF_T_MICROTIME | BPF_T_FFCLOCK)
+#define BPF_T_NANOTIME_FFCLOCK		(BPF_T_NANOTIME | BPF_T_FFCLOCK)
+#define BPF_T_BINTIME_FFCLOCK		(BPF_T_BINTIME | BPF_T_FFCLOCK)
+#endif
 
 /*
  * Structure prepended to each packet.
@@ -193,6 +218,18 @@
 	bpf_int64	bt_sec;		/* seconds */
 	bpf_u_int64	bt_frac;	/* fraction */
 };
+
+#ifdef RADCLOCK
+struct bpf_xhdr {
+	struct bpf_ts	bh_tstamp;	/* time stamp */
+	bpf_u_int32	bh_caplen;	/* length of captured portion */
+	bpf_u_int32	bh_datalen;	/* original length of packet */
+	u_short		bh_hdrlen;	/* length of bpf header (this struct
+					   plus alignment padding) */
+	u_short		padding;		/* padding to align the fields */
+	vcounter_t	vcount_stamp;	/* raw virtual timecounter timestamp for this packet */
+};
+#else
 struct bpf_xhdr {
 	struct bpf_ts	bh_tstamp;	/* time stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
@@ -200,7 +237,20 @@
 	u_short		bh_hdrlen;	/* length of bpf header (this struct
 					   plus alignment padding) */
 };
+#endif
+
 /* Obsolete */
+#ifdef RADCLOCK
+struct bpf_hdr {
+	struct timeval	bh_tstamp;	/* time stamp */
+	bpf_u_int32	bh_caplen;	/* length of captured portion */
+	bpf_u_int32	bh_datalen;	/* original length of packet */
+	u_short		bh_hdrlen;	/* length of bpf header (this struct
+					   plus alignment padding) */
+	u_short		padding;		/* padding to align the fields */
+	vcounter_t	vcount_stamp;	/* raw virtual timecounter timestamp for this packet */
+};
+#else
 struct bpf_hdr {
 	struct timeval	bh_tstamp;	/* time stamp */
 	bpf_u_int32	bh_caplen;	/* length of captured portion */
@@ -208,6 +258,7 @@
 	u_short		bh_hdrlen;	/* length of bpf header (this struct
 					   plus alignment padding) */
 };
+#endif
 #ifdef _KERNEL
 #define	MTAG_BPF		0x627066
 #define	MTAG_BPF_TIMESTAMP	0
diff -aur --unidirectional-new-file sys/net/bpfdesc.h FreeBSD-CURRENT/net/bpfdesc.h
--- sys/net/bpfdesc.h	2010-11-30 21:40:39.000000000 +1100
+++ FreeBSD-CURRENT/net/bpfdesc.h	2010-11-30 21:41:40.000000000 +1100
@@ -99,6 +99,9 @@
 	u_int64_t	bd_wdcount;	/* number of packets dropped during a write */
 	u_int64_t	bd_zcopy;	/* number of zero copy operations */
 	u_char		bd_compat32;	/* 32-bit stream on LP64 system */
+//#ifdef RADCLOCK
+//	int8_t	radclock_tsmode;	/* Timestamping mode for the RADclock */
+//#endif /* RADCLOCK */
 };
 
 /* Values for bd_state */
diff -aur --unidirectional-new-file sys/net/if_ethersubr.c FreeBSD-CURRENT/net/if_ethersubr.c
--- sys/net/if_ethersubr.c	2010-11-30 21:40:39.000000000 +1100
+++ FreeBSD-CURRENT/net/if_ethersubr.c	2010-11-30 21:41:40.000000000 +1100
@@ -36,6 +36,7 @@
 #include "opt_ipx.h"
 #include "opt_netgraph.h"
 #include "opt_mbuf_profiling.h"
+#include "opt_radclock.h"
 
 #include <sys/param.h>
 #include <sys/systm.h>
@@ -49,6 +50,9 @@
 #include <sys/socket.h>
 #include <sys/sockio.h>
 #include <sys/sysctl.h>
+#ifdef RADCLOCK
+#include <sys/time.h>
+#endif
 
 #include <net/if.h>
 #include <net/if_arp.h>
diff -aur --unidirectional-new-file sys/sys/time.h FreeBSD-CURRENT/sys/time.h
--- sys/sys/time.h	2010-11-30 21:40:40.000000000 +1100
+++ FreeBSD-CURRENT/sys/time.h	2010-11-30 21:41:40.000000000 +1100
@@ -324,6 +324,55 @@
 void	getnanotime(struct timespec *tsp);
 void	getmicrotime(struct timeval *tvp);
 
+/* RADCLOCK specific */
+typedef uint64_t vcounter_t;
+
+/* RADclock synchronisation structure */
+
+//struct radclock_data {
+//	double 		phat;
+//	double 		phat_err;
+//	double 		phat_local;
+//	double 		phat_local_err;
+//	long double	ca;
+//	double 		ca_err;
+//	uint32_t	status;
+//	vcounter_t	last_changed;
+//	vcounter_t	valid_till;
+//};
+
+struct radclock_fixedpoint
+{
+	/* phat as an int shifted phat_shift to the left */
+	uint64_t phat_int;
+	/* Record of last time update from synchronization algorithm as an int */
+	uint64_t time_int;
+	/* The counter value to convert in seconds */
+	vcounter_t vcount;
+	/* the shift amount for phat_int */
+	uint8_t phat_shift;
+	/* the shift amount for time_int */
+	uint8_t time_shift;
+	/* Warn if stamp is over this many bits */
+	uint8_t countdiff_maxbits;
+};
+
+
+struct feedfwd_clock
+{
+	uint8_t generation;
+	struct radclock_fixedpoint *estimate;
+	struct radclock_fixedpoint *estimate_old;
+	struct radclock_fixedpoint *tmp;
+};
+
+
+
+vcounter_t read_vcounter(void);
+void radclock_vcount2bintime(vcounter_t *vcount, struct bintime *bt);
+/* RADCLOCK */
+
+
 /* Other functions */
 int	itimerdecr(struct itimerval *itp, int usec);
 int	itimerfix(struct timeval *tv);
diff -aur --unidirectional-new-file sys/sys/timepps.h FreeBSD-CURRENT/sys/timepps.h
--- sys/sys/timepps.h	2010-11-30 21:40:40.000000000 +1100
+++ FreeBSD-CURRENT/sys/timepps.h	2010-11-30 21:41:40.000000000 +1100
@@ -15,6 +15,8 @@
 #ifndef _SYS_TIMEPPS_H_
 #define _SYS_TIMEPPS_H_
 
+#include "opt_radclock.h"
+
 #include <sys/ioccom.h>
 #include <sys/time.h>
 
@@ -43,12 +45,35 @@
 	int		current_mode;		/* current mode bits */
 } pps_info_t;
 
+
+#ifdef RADCLOCK
+typedef union pps_vcounteru {
+	vcounter_t vcount;
+} pps_vcounteru_t;
+
+typedef struct {
+	pps_seq_t	assert_sequence;	/* assert event seq # */
+	pps_seq_t	clear_sequence;		/* clear event seq # */
+	pps_timeu_t	assert_tu;
+	pps_timeu_t	clear_tu;
+	int		current_mode;		/* current mode bits */
+	pps_vcounteru_t  assert_vcu;
+	pps_vcounteru_t  clear_vcu;
+} radclock_pps_info_t;
+#endif	/* RADCLOCK */
+
+
 #define assert_timestamp        assert_tu.tspec
 #define clear_timestamp         clear_tu.tspec
 
 #define assert_timestamp_ntpfp  assert_tu.ntpfp
 #define clear_timestamp_ntpfp   clear_tu.ntpfp
 
+#ifdef RADCLOCK
+#define assert_vcount		assert_vcu.vcount
+#define clear_vcount		clear_vcu.vcount
+#endif 	/* RADCLOCK */
+
 typedef struct {
 	int api_version;			/* API version # */
 	int mode;				/* mode bits */
@@ -89,6 +114,14 @@
 	struct timespec	timeout;
 };
 
+#ifdef RADCLOCK
+struct radclock_pps_fetch_args {
+	int tsformat;
+	radclock_pps_info_t	pps_info_buf;
+	struct timespec	timeout;
+};
+#endif	/* RADCLOCK */
+
 struct pps_kcbind_args {
 	int kernel_consumer;
 	int edge;
@@ -102,6 +135,9 @@
 #define PPS_IOC_GETCAP		_IOR('1', 5, int)
 #define PPS_IOC_FETCH		_IOWR('1', 6, struct pps_fetch_args)
 #define PPS_IOC_KCBIND		_IOW('1', 7, struct pps_kcbind_args)
+#ifdef RADCLOCK
+#define RADCLOCK_PPS_IOC_FETCH		_IOWR('1', 8, struct radclock_pps_fetch_args)
+#endif 	/* RADCLOCK */
 
 #ifdef _KERNEL
 
@@ -114,6 +150,9 @@
 	/* State information. */
 	pps_params_t	ppsparam;
 	pps_info_t	ppsinfo;
+#ifdef RADCLOCK
+	radclock_pps_info_t	radclock_ppsinfo;
+#endif 	/* RADCLOCK */
 	int		kcmode;
 	int		ppscap;
 	struct timecounter *ppstc;
@@ -183,6 +222,26 @@
 	return (error);
 }
 
+#ifdef RADCLOCK
+static __inline int
+radclock_pps_fetch(pps_handle_t handle, const int tsformat,
+	radclock_pps_info_t *ppsinfobuf, const struct timespec *timeout)
+{
+	int error;
+	struct radclock_pps_fetch_args arg;
+
+	arg.tsformat = tsformat;
+	if (timeout == NULL) {
+		arg.timeout.tv_sec = -1;
+		arg.timeout.tv_nsec = -1;
+	} else
+		arg.timeout = *timeout;
+	error = ioctl(handle, RADCLOCK_PPS_IOC_FETCH, &arg);
+	*ppsinfobuf = arg.pps_info_buf;
+	return (error);
+}
+#endif 	/* RADCLOCK */
+
 static __inline int
 time_pps_kcbind(pps_handle_t handle, const int kernel_consumer,
 	const int edge, const int tsformat)
diff -aur --unidirectional-new-file sys/sys/timetc.h FreeBSD-CURRENT/sys/timetc.h
--- sys/sys/timetc.h	2010-11-30 21:40:40.000000000 +1100
+++ FreeBSD-CURRENT/sys/timetc.h	2010-11-30 21:41:40.000000000 +1100
@@ -16,6 +16,8 @@
 #error "no user-serviceable parts inside"
 #endif
 
+#include "opt_radclock.h"
+
 /*-
  * `struct timecounter' is the interface between the hardware which implements
  * a timecounter and the MI code which uses this to keep track of time.
@@ -62,6 +64,14 @@
 		/* Pointer to the timecounter's private parts. */
 	struct timecounter	*tc_next;
 		/* Pointer to the next timecounter. */
+#ifdef RADCLOCK
+	uint64_t (*tc_get_timecount_64) (struct timecounter *);
+		/*
+		 * This function reads the counter and return a 64 bit unsigned int.
+		 * It is used for the passthrough mode, required by feed-forward
+		 * clocks in a virtual system (eg. Xen)
+		 */
+#endif 
 };
 
 extern struct timecounter *timecounter;
