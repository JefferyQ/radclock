diff --git a/include/linux/time.h b/include/linux/time.h
index fe04e5e..2824c9a 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -237,6 +237,34 @@ static __always_inline void timespec_add_ns(struct timespec *a, u64 ns)
 	a->tv_sec += __iter_div_u64_rem(a->tv_nsec + ns, NSEC_PER_SEC, &ns);
 	a->tv_nsec = ns;
 }
+
+#ifdef CONFIG_FFCLOCK
+/* Feed-forward time type (ffclock) */
+typedef u64 ffcounter_t;
+
+struct ffclock_estimate {
+	/* phat shifted phat_shift units to the left */
+	u64 phat_int;
+	/* last time update from synchronization algorithm */
+	u64 time_int;
+	/* the counter value that will be converted to seconds */
+	ffcounter_t ffcounter;
+	/* the shift amount for phat_int */
+	u64 phat_shift;
+	/* the shift amount for time_int */
+	u64 time_shift;
+	/* warn if stamp exceeds this many bits */
+	u64 countdiff_maxbits;
+};
+
+/* Current feed-forward estimation of time and the previous estimate */
+struct ffclock {
+	u8 generation;
+	struct ffclock_estimate *cest;
+	struct ffclock_estimate *ocest;
+	struct ffclock_estimate *tmp;
+};
+#endif /* CONFIG_FFCLOCK */
 #endif /* __KERNEL__ */
 
 #define NFDBITS			__NFDBITS
diff --git a/kernel/time/Kconfig b/kernel/time/Kconfig
index 95ed429..504ca28 100644
--- a/kernel/time/Kconfig
+++ b/kernel/time/Kconfig
@@ -27,3 +27,10 @@ config GENERIC_CLOCKEVENTS_BUILD
 	default y
 	depends on GENERIC_CLOCKEVENTS || GENERIC_CLOCKEVENTS_MIGR
 
+config FFCLOCK
+        bool
+        depends on EXPERIMENTAL
+        default y
+        help
+          This option enables feed-forward clock estimation ideally based on
+          the hardware counter value of the system's clock.
diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c
index c3a4e29..b4458f2 100644
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@ -45,10 +45,27 @@ struct timekeeper {
 	int	ntp_error_shift;
 	/* NTP adjusted clock multiplier */
 	u32	mult;
+
+#ifdef CONFIG_FFCLOCK
+	/* Feed-forward counter record for the timekeeper */
+	ffcounter_t       ffcounter_record;
+#endif
 };
 
 struct timekeeper timekeeper;
 
+#ifdef CONFIG_FFCLOCK
+/* Global feed-forward clock estimate */
+static struct ffclock ffclock;
+
+static void init_ffclock(struct ffclock *ffclock);
+static void reset_ffclock(struct ffclock *ffclock,
+			    const struct clocksource *clock,
+			    int new_clocksource);
+static void update_ffclock(struct ffclock *ffclock);
+static ffcounter_t read_ffcounter(void);
+#endif /* CONFIG_FFCLOCK */
+
 /**
  * timekeeper_setup_internals - Set up internals to use clocksource clock.
  *
@@ -95,6 +112,10 @@ static void timekeeper_setup_internals(struct clocksource *clock)
 	 * to counteract clock drifting.
 	 */
 	timekeeper.mult = clock->mult;
+
+#ifdef CONFIG_FFCLOCK
+	reset_ffclock(&ffclock, clock, 0);
+#endif
 }
 
 /* Timekeeper helper functions. */
@@ -337,6 +358,10 @@ int do_settimeofday(struct timespec *tv)
 	timekeeper.ntp_error = 0;
 	ntp_clear();
 
+#ifdef CONFIG_FFCLOCK
+	reset_ffclock(&ffclock, timekeeper.clock, 0);
+#endif
+
 	update_vsyscall(&xtime, timekeeper.clock);
 
 	write_sequnlock_irqrestore(&xtime_lock, flags);
@@ -363,10 +388,16 @@ static int change_clocksource(void *data)
 	timekeeping_forward_now();
 	if (!new->enable || new->enable(new) == 0) {
 		old = timekeeper.clock;
+
+#ifdef CONFIG_FFCLOCK
+		reset_ffclock(&ffclock, timekeeper.clock, 1);
+#endif
+
 		timekeeper_setup_internals(new);
 		if (old->disable)
 			old->disable(old);
 	}
+
 	return 0;
 }
 
@@ -533,6 +564,10 @@ void __init timekeeping_init(void)
 
 	ntp_init();
 
+#ifdef CONFIG_FFCLOCK
+	init_ffclock(&ffclock);
+#endif
+
 	clock = clocksource_default_clock();
 	if (clock->enable)
 		clock->enable(clock);
@@ -551,6 +586,7 @@ void __init timekeeping_init(void)
 	update_xtime_cache(0);
 	total_sleep_time.tv_sec = 0;
 	total_sleep_time.tv_nsec = 0;
+
 	write_sequnlock_irqrestore(&xtime_lock, flags);
 }
 
@@ -812,6 +848,11 @@ void update_wall_time(void)
 
 	/* check to see if there is a new clocksource to use */
 	update_vsyscall(&xtime, timekeeper.clock);
+
+#ifdef CONFIG_FFCLOCK
+	timekeeper.ffcounter_record += offset;
+	update_ffclock(&ffclock);
+#endif
 }
 
 /**
@@ -886,3 +927,108 @@ struct timespec get_monotonic_coarse(void)
 				now.tv_nsec + mono.tv_nsec);
 	return now;
 }
+
+/*
+ * Feed-forward Clock Functionality
+ */
+#ifdef CONFIG_FFCLOCK
+
+/*
+ * init_ffclock - Initializes the feed-forward clock estimate
+ */
+static void init_ffclock(struct ffclock *ffclock)
+{
+	const size_t sz = sizeof(struct ffclock_estimate);
+
+	memset(ffclock, 0, sz);
+	ffclock->cest = kzalloc(sz, 0);
+	ffclock->ocest = kzalloc(sz, 0);
+}
+
+/*
+ * reset_ffclock - Sets-up the ffclock to initial values
+ * @new_clocksource: If TRUE, the timekeeper's picture is reset
+ *
+ * This is called if we switch clocksources.
+ */
+static void reset_ffclock(struct ffclock *ffclock,
+			    const struct clocksource *clock,
+			    int new_clocksource)
+{
+	u64 clock_freq, phat_div;
+	struct timespec boot;
+	struct ffclock_estimate *cest = ffclock->cest;
+
+	/* If we changed clocksources reset the timekeeper's picture */
+	if (new_clocksource) {
+		timekeeper.ffcounter_record = 0;
+		cest->ffcounter = 0;
+	} else
+		cest->ffcounter = read_ffcounter();
+
+	cest->phat_shift = 58;
+	cest->time_shift = 32;
+	cest->countdiff_maxbits = 30;
+
+	read_boot_clock(&boot);
+
+	/* Clock multiplier to cycles-per-second */
+	clock_freq = clocksource_cyc2ns(1, clock->mult, clock->shift);
+
+	phat_div = 1LL << 63;
+	do_div(phat_div, clock_freq);
+	cest->phat_int = phat_div >> (63 - cest->phat_shift);
+	cest->time_int = (boot.tv_sec << cest->time_shift)
+			 + (boot.tv_nsec >> (64 - cest->time_shift));
+
+	/* We are only resetting and not re-initializing, keep incrementing */
+	++ffclock->generation;
+}
+
+/*
+ * update_ffclock - Update the ffclock which prevents overflow.
+ *
+ * The clock's parameters are not modified here.
+ */
+static void update_ffclock(struct ffclock *ffclock)
+{
+	struct ffclock_estimate *cest;
+	ffcounter_t cdiff;
+
+	cest = ffclock->cest;
+
+	/* If thet clock has just changed sources or has been adjusted we can
+	 * ignore the update
+	 */
+	if (cest->ffcounter > timekeeper.ffcounter_record)
+		return;
+
+	/* Advance the generation and current estimate */
+	cdiff = timekeeper.ffcounter_record - cest->ffcounter;
+	cest->time_int += ((cest->phat_int * cdiff) >>
+			  (cest->phat_shift - cest->time_shift));
+	cest->ffcounter = timekeeper.ffcounter_record;
+
+	/* Avoid overflow errors */
+	++ffclock->generation;
+	if (ffclock->generation == 0)
+		ffclock->generation = 1;
+}
+
+/*
+ * read_ffcounter - Returns the hardware counter's value
+ */
+static ffcounter_t read_ffcounter(void)
+{
+	cycle_t offset;
+	struct clocksource *clock = timekeeper.clock;
+
+#ifdef CONFIG_GENERIC_TIME
+	offset = (clock->read(clock) - clock->cycle_last) & clock->mask;
+#else
+	offset = timekeeper.cycle_interval;
+#endif
+
+	return timekeeper.ffcounter_record + offset;
+}
+#endif /* CONFIG_FFCLOCK */
